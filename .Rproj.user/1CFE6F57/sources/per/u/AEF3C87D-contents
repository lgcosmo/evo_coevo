wA = 0.5 # Step 1
wB = 1 # Step 1

p = seq(0, 1, 0.001)
w_avg = p*wA + (1-p)*wB #Step 3

land = data.frame(p, w_avg) #Building a data frame with values of p and the corresponding average fitness

# Plotting the landscape.

ggplot()+
  geom_line(data=land, aes(x=p, y=w_avg))+
  xlab("Frequency of allele A")+ylab("Average fitness of the population")+
  theme_pubr()


evo_landscape<-function(tmax, p0, wA, wB){ #Defining the function and the input arguments
  
  p_theo = seq(0, 1, 0.001) # Defining the theoretical values of p to build the fitness landscape
  w_avg_theo = p_theo*wA + (1-p_theo)*wB #Computing the average fitness
  land = data.frame(p_theo, w_avg_theo) #Building a data frame with values of p and the corresponding average fitness
  
  dp = c() #Creating the vector to store the outcome
  dw = c() #Creating a vector to keep track of the average fitness along the evolutionary dynamics
  dp[1]<-p0 #Setting the initial frequency of p
  
  for(t in 1:(tmax-1)){ #Setting up the for loop
    
    p = dp[t] # Setting current frequencies
    w_avg = p*wA + (1-p)*wB # Computing average fitness
    dw[t] = w_avg
    dp[t+1]= p + (p*(1-p)*(wA-wB)/w_avg) #Updating frequency values
    
  }
  
  dw[tmax] =  dp[tmax]*wA + (1-dp[tmax])*wB #Computing average fitness for the final time step
  r = data.frame(dp=dp, dw, t=1:tmax) # Building the data frame
  
  return(list(land, r)) # Returning a list with the data frame of the dynamics and the landscape, respectively
  
}
# Running the function to test it:

r_list = evo_landscape(tmax=20, p0=0.2, wA=1, wB=1.5)

# Plotting the landscape and how the population moves over generations

ggplot()+
  geom_line(data=r_list[[1]], aes(x=p_theo, y=w_avg_theo))+
  geom_point(data=r_list[[2]], aes(x=dp, y=dw, fill=t), color="black", shape=21, size=3)+
  scale_fill_gradientn(colors=c("white", "black"))+
  labs(fill="Generation")+
  xlab("Frequency of allele A")+ylab("Average fitness of the population")+
  theme_pubr()

evo_landscape<-function(tmax, p0, alpha, beta){ #Defining the function and the input arguments
  
  p_theo = seq(0, 1, 0.001) # Defining the theoretical values of p to build the fitness landscape
  wA_theo = 1 - (alpha*p_theo) # Defining the fitness function of A
  wB_theo = 1 - (beta*(1-p_theo)) # Defining the fitness function of A
  w_avg_theo = p_theo*wA_theo + (1-p_theo)*wB_theo #Computing the average fitness
  land = data.frame(p_theo, w_avg_theo) #Building a data frame with values of p and the corresponding average fitness
  
  dp = c() #Creating the vector to store the outcome
  dw = c() #Creating a vector to keep track of the average fitness along the evolutionary dynamics
  dp[1]<-p0 #Setting the initial frequency of p
  
  for(t in 1:(tmax-1)){ #Setting up the for loop
    
    p = dp[t] # Setting current frequencies
    wA = 1-(alpha*p) #Computing the fitness of A at the current generation
    wB = 1-(beta*(1-p)) #Computing the fitness of B at the current generation
    w_avg = p*wA + (1-p)*wB # Computing average fitness
    dw[t] = w_avg
    dp[t+1]= p + (p*(1-p)*(wA-wB)/w_avg) #Updating frequency values
    
  }
  dw[tmax] =  dp[tmax]*wA + (1-dp[tmax])*wB #Computing average fitness for the final time step
  r = data.frame(dp=dp, dw, t=1:tmax) # Building the data frame
  
  return(list(land, r)) # Returning a list with the data frame of the dynamics and the landscape, respectively
  
}

r_list = evo_landscape(tmax=50, p0=0.2, alpha=0.1, beta=0.2)

# Plotting the landscape and how the population moves over generations

ggplot()+
  geom_line(data=r_list[[1]], aes(x=p_theo, y=w_avg_theo))+
  geom_point(data=r_list[[2]], aes(x=dp, y=dw, fill=t), color="black", shape=21, size=3)+
  scale_fill_gradientn(colors=c("white", "black"))+
  labs(fill="Generation")+
  xlab("Frequency of allele A")+ylab("Average fitness of the population")+
  theme_pubr()
