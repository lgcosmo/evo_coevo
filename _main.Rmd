---
title: "Introduction to evolutionary and coevolutionary theory"
author: "Leandro G. Cosmo"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
# url: your book url like https://bookdown.org/yihui/bookdown
# cover-image: path to the social sharing image like images/cover.jpg
description: |
  This is the webpage for the course "Introduction to evolutionary and coevolutionary theory". Here you will find the course schedule, as well as all of the lecture notes.
link-citations: yes
github-repo: lgcosmo/evo_coevo
---

```{=html}
<style>
body {
text-align: justify}
</style>
```
# Preface

Coevolution, the reciprocal evolutionary influence between two or more interacting species, underpins the diversity and complexity of ecosystems. However, understanding coevolution in empirical systems is challenging because of the different time scales at which coevolution operates. Mathematical models, in turn, enable us to simulate various scenarios, predict outcomes, and test hypotheses, providing a deeper understanding of how coevolution shapes biodiversity, ecological stability, and the emergence of new traits. Therefore, the main goal of the course is to introduce the basic concepts and tools that can be used to model coevolution in ecological communities. To do so, the course is divided into two blocks. In the first block, we will introduce the main concepts and the mathematical foundations of evolutionary biology that will be used to model coevolution. For the second block we will provide an overview on how to build coevolutionary models from basic evolutionary and ecological principles. The coevolutionary models covered in the course can be applied to both discrete and continuously varying traits, for instance, the frequency of different flower color morphs in a population of plants or the length of their floral tube, respectively. Furthermore, we will demonstrate how to progress the coevolutionary models from isolated pairwise of interacting species to entire communities that form networks. Conceptual lectures will occur in the morning, from 10:00-12:00am. The conceptual lectures will be followed by an exercise section in the afternoon, from 14:00-17:00pm, where the models will be implemented via computer simulations and analyzed.

At a future date this page will be updated to include the lecture notes, as well as the instructions for the exercise sections of each of the lectures. If you have any questions, please feel free to send me an e-mail. I will be happy to help!

## Registration

For the present iteration of the course, registration will take place between **10.06.2024** and **27.06.2024**. The Ecology graduate program of Universidade Estadual de Campinas requires students to register using the following forms:

1)  ["Estudantes regulares"](https://drive.google.com/file/d/1fRILwlcdKFloCCqvmGSjI9ucSElKDnaJ/view) - for students of the Ecology graduate program of Universidade Estadual de Campinas
2)  ["Estudantes especiais"](https://www.dac.unicamp.br/sistemas/formularios/inscricao_disciplinas_eventuais_pos_aut.php) - for students of different programs or institutions.

Please, fill the appropriate form and send it to the email [leandro.giacobellicosmo\@uzh.ch](mailto:leandro.giacobellicosmo@uzh.ch){.email} with the subject "Course pre-registration". Even though this page and course notes are in english, **all of the lectures of the course will be in Portuguese.** The course will award 2 credits.

## Course schedule

All of the lectures of the course will be held **in-person**, at the Instituto de Biologia of the Universidade Estadual de Campinas. Throughout the two blocks of the course we will study the following topics:

**Block 1 -- Evolution by natural selection and the fundamental equations of evolutionary theory**

1)  Introduction to the course: why do we need evolution and coevolution to understand ecological communities?
2)  Wright's equation for the adaptive landscape of genotypes.
3)  The algebra of evolution -- Price's theorem and the different modes of selection.
4)  Lande's equation, the selection gradient, and the adaptive landscape of phenotypes.

**Block 2 - Ecological interactions as reciprocal selective pressures: coevolution in ecological communities**

1)  Coevolution of discrete morphs/haploid individuals: ecological interactions mediated by a gene-for-gene or matching allele mechanism.
2)  Coevolution of continuously varying traits: when trait matching, and exploitation barriers mediate the outcome of ecological interactions.
3)  Coevolution in species-rich ecological communities: the role of indirect evolutionary effects.

The day-to-day schedule can be found below:

**Lectures of the first block:**

+-------------------------+---------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------+
|                         | Day 1 (16.07.2024)                                                                                                              | Day 2 (17.07.2024)                                                                                              | Day 3 (18.07.2024)                                                                      |
+:=======================:+:===============================================================================================================================:+:===============================================================================================================:+:=======================================================================================:+
| Morning lecture         | Introduction to the course and how can we model evolutionary changes in the frequencies of morphs (Wright's adaptive landscape) | The algebra of evolution - Price's theorem and the different modes of selection                                 | Modelling the evolution of continuous traits - Lande's equation and selection gradients |
|                         |                                                                                                                                 |                                                                                                                 |                                                                                         |
| (from 10:00 to 12:00am) |                                                                                                                                 |                                                                                                                 |                                                                                         |
+-------------------------+---------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------+
| Exercise section        | Using simulations to understand the evolution and adaptive landscape of discrete morphs                                         | Using the Price equation and linear regressions to understand directional, stabilizing and disruptive selection | Using Lande's equation to simulate the adaptive landscape of continuous traits          |
|                         |                                                                                                                                 |                                                                                                                 |                                                                                         |
| (from 14:00 to 16:00pm) |                                                                                                                                 |                                                                                                                 |                                                                                         |
+-------------------------+---------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------+

**Lectures of the second block:**

+-------------------------+--------------------------------------------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------+
|                         | Day 1 (23.07.2024)                                                                   | Day 2 (24.07.2024)                                                               | Day 3 (25.07.2024)                                                                          |
+:=======================:+:====================================================================================:+:================================================================================:+:===========================================================================================:+
| Morning lecture         | Coevolution of interactions mediated by a matching allele or gene-for-gene mechanism | Coevolution of interactions mediated by trait matching and exploitation barriers | Coevolution in species-rich communities: the role of indirect evolutionary effects          |
|                         |                                                                                      |                                                                                  |                                                                                             |
| (from 10:00 to 12:00am) |                                                                                      |                                                                                  |                                                                                             |
+-------------------------+--------------------------------------------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------+
| Exercise section        | Simulating and analyzing our first coevolutionary model                              | Simulating and analyzing models of coevolution of continuous traits              | Simulating coevolution in ecological networks and quantifying indirect evolutionary effects |
|                         |                                                                                      |                                                                                  |                                                                                             |
| (from 14:00 to 16:00pm) |                                                                                      |                                                                                  |                                                                                             |
+-------------------------+--------------------------------------------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------+

## Bibliography

The course will follow two main books. For the first block, most of the lectures and lecture notes will be inspired by the amazing book by Sean H. Rice, *Evolutionary Theory: Mathematical and Conceptual Foundations*. During the second block we will use a combination of research papers and the book *Introduction to Coevolutionary Theory* by Scott Nuismer. The complete list of references and additional readings (in case you are interested) can be found below:

Agrawal, A.A. & Zhang, X. (2021). The evolution of coevolution in the study of species interactions. *Evolution*, 75, 1594--1606.

de Andreazzi, C.S., Astegiano, J. & Guimarães, P.R., Jr. (2020). Coevolution by different functional mechanisms modulates the structure and dynamics of antagonistic and mutualistic networks. *Oikos*, 129,224--237.\
\
Andreazzi, C.S., Thompson, J.N. & Guimarães, P.R., Jr. (2017). Network Structure and Selection Asymmetry Drive Coevolution in Species-Rich Antagonistic Interactions. *Am. Nat.*, 190, 99--115.

Buckingham, L.J. & Ashby, B. (2022). Coevolutionary theory of hosts and parasites. *J. Evol. Biol.*, 35, 205--224.

Cogni, R., Quental, T.B. & Guimarães, P.R., Jr. (2022). Ehrlich and Raven escape and radiate coevolution hypothesis at different levels of organization: Past and future perspectives. *Evolution*, 76, 1108--1123.

Cosmo, L.G., Assis, A.P.A., de Aguiar, M.A.M., Pires, M.M., Valido, A., Jordano, P., *et al.* (2023). Indirect effects shape species fitness in coevolved mutualistic networks. *Nature*, 1--5.

Ehrlich, P.R. & Raven, P.H. (1964). Butterflies and plants: a study in coevolution. *Evolution*, 18, 586--608.

Guimarães, P.R., Jr, Pires, M.M., Jordano, P., Bascompte, J. & Thompson, J.N. (2017). Indirect effects drive coevolution in mutualistic networks. *Nature*, 550, 511--514.

Janzen, D.H. (1980). When is it Coevolution? *Evolution*, 34, 611--612.

Lande, R. (1976). Natural selection and random genetic drift in phenotypic evolution. *Evolution*, 30, 314.

Miller, T.E. & Travis, J. (1996). The Evolutionary Role of Indirect Effects in Communities. *Ecology*, 77, 1329--1335.

Nuismer, S. (2017). *Introduction to Coevolutionary Theory*. 1st edn. W. H. Freeman.

Rice, S.H. (2004). *Evolutionary Theory: Mathematical and Conceptual Foundations*.

Thompson, J.N. & Burdon, J.J. (1992). Gene-for-gene coevolution between plants and parasites. *Nature*, 360, 121--125.

Thompson, J.N. (1994). *The coevolutionary process*. Univ. of Chicago Press, Chicago.

Thompson, J.N. (2009). The coevolving web of life. *Am. Nat.*, 173, 125--140.

Wright, S. (1937). The Distribution of Gene Frequencies in Populations. *Proceedings of the National Academy of Sciences*, 23, 307--320.

<!--chapter:end:index.Rmd-->

```{=html}
<style>
body {
text-align: justify}
</style>
```
# Introduction to the course

> "There is grandeur in this view of life, with its several powers, having been originally breathed into a few forms or into one; and that, whilst this planet has gone cycling on according to the fixed law of gravity, from so simple a beginning endless forms most beautiful and most wonderful have been, and are being, evolved."

The above quotation is one of the most iconic ones in biology. It beautifully concludes *The* *Origin of Species* by *Charles R. Darwin*, emphasizing the diversity of forms that we can find in nature, and how natural selection can shape these forms. Indeed, even in a simple walk through our neighborhood we can find hundreds of organisms, from plants to animals, with varying forms. From this observation, a natural question is then, how all these forms came to be?

To answer this question, we need to address two main problems. First, we need to assess the set of processes that act as a source of heritable variation on traits. Then, we need to understand how a second set of processes act upon the available heritable variation and shape traits. Our course focuses on this second problem. Specifically, we will study the theory and the mathematical foundations behind one of the main processes that can act upon heritable variation in populations: **natural selection**.

Throughout the first block, we will derive from first principles and gain some intuition about the main equations that predict how natural selection should drive evolution. In the second block, we will then use these equations to study ecological interactions as a source of reciprocal selective pressures that drive the coevolution between species.

## The fundamental concepts of evolution by natural selection

First things first, we need a definition of evolution so that we can start from there. Following Futuyma (2005), evolution can be defined as a "change in the properties of groups of organisms over the course of generations". Note that the *properties* in this definition of evolution "...embraces everything from slight changes in the proportions of different forms of a gene within a population to the alterations that led from the earliest organism to dinosaurs, bees, oaks, and humans" (Futuyma 2005). Throughout the course we will focus on how natural selection can drive the evolution of properties that can be measured as discrete or continuous traits in a population. Two biological examples of discrete and continuous traits would be the frequency of alleles that determine discrete floral morphs, or the length of floral tubes in population of plants, respectively. We will also focus on how these traits change within populations, or microevolutionary changes, in contrast with changes that could occur above the level of species, or macroevolutionary changes (Turner *et al.* 2009).

With this definition in hand, our first question is then **how natural selection can drive changes in discrete or continuous traits in populations from one generation to the other?** Before attempting to answer the question, we also need to define natural selection. Definitions are important because they allow us to build our models from fundamental propositions and assumptions that we know are true, or, the so called *first principles*. We can define natural selection as the differential survival and reproduction of individuals due to differences in heritable traits (Rice 2004). From this definition we can identify the three fundamental propositions that allow natural selection to operate:

1.  Traits need to vary between individuals in a population.

2.  These traits need to be heritable.

3.  Individuals with different traits need to differ in how much they contribute with reproduction to the next generation.

In evolutionary biology the word *fitness* is used to convey the reproductive contribution of an individual to the next generation (Rice 2004), and this is the definition of *fitness* that we will use throughout this course. Now that we have defined the scope of our problem (microevolution of discrete and continuous traits) and the first principles underlying our process of interest (the three propositions of natural selection), we can start to mathematically describe the problem.

## Natural selection and the evolution of allele frequencies within populations

### Building our first equation

Natural populations are complex, and it would be impossible to incorporate all the details that we can find when we mathematically describe a problem. Not only it would be impossible, but it would severely hinder our ability to understand and disentangle how our process of interest operates. Thus, our first step is to make some simplifying assumptions about these populations. Understanding what simplifying assumptions are reasonable is a complex topic and to learn more about this problem I highly recommend starting with the classic paper by Richard Levins, *The strategy of model building in population biology*. The short answer is that the choice of simplifying assumptions depends on your problem of interest and the questions that you are trying to answer.

Here, we are concerned about how populations evolve by means of natural selection. So, our first simplifying assumption is that the only mechanism of evolutionary change within a population is natural selection and that generations are non-overlapping. Our next step is to incorporate the fundamental propositions through which natural selection operates. The first one is that individuals vary in their traits. For these traits, we will assume the simplest case, in which a population contains individuals with only two discrete morphs/traits, for instance, plant individuals that produce only white flowers or purple flowers. From the second proposition, these traits need to be heritable. So, we will also assume that individuals are haploid, that two alleles, $A$ and $B$, determine the two morphs (e.g. the white and purple morphs), and that these alleles are inherited by the offspring of individuals. Finally, each of the $N_A$ or $N_B$ individuals carrying the $A$ or $B$ alleles contributes to the next generation with an amount of $W_A$ and $W_B$ of individuals that inherit the $A$ and $B$ alleles, respectively. Thus, $W_A$ and $W_B$ represent the *fitness* of these individuals. Figure 1 below illustrates this scenario using the example of plant individuals displaying white or purple flowers.

![Fig. 1 - Theoretical example showing how the number of individuals of different morphs in a population can change from one generation to the other. For simplicity, in this example we assume that individuals are haploid and that two alleles, A and B, determine the white and purple floral morphs, respectively.](figs/fig1.png){width="65%"}

$\\$

Under the above assumptions, in the next generation the total number of individuals carrying the allele $A$ in the population will depend on how much each individual contribute with offspring to the next generation. Mathematically, this is equivalent to multiply the current number of individuals carrying the allele $A$, with their *fitness*, as follows:

$$N_{A}^{(t+1)}=N_{A}^{(t)}W_{A}^{(t)}$$

where the superscripts $(t)$ and $(t+1)$ denotes the current and the next generation, respectively. Similarly, the following equation describes the number of individuals carrying the $B$ allele in the next generation: $$N_{B}^{(t+1)}=N_{B}^{(t)}W_{B}^{(t)}$$ However, we are interested in how the frequencies of these alleles change, not the absolute number of individuals. Since there are only two alleles in the population, if we find the frequency - $p$ - of allele $A$, then the frequency of $B$ is equal to $(1-p)$. The frequency of $A$ in the next generation is equal to the number of individuals carrying $A$, divided by total number of individuals in the next generation, $\frac{N_{A}^{(t+1)}}{N^{(t+1)}}$. We already know what $N_{A}^{(t+1)}$ is, so our next step is to find what will be the total number of individuals in the next generation, $N^{(t+1)}$. From the two equations above, we know that the total population size at the next generation is equal to:

$$N^{(t+1)}=N_{A}^{(t)}W_{A}^{(t)}+N_{B}^{(t)}W_{B}^{(t)}$$

We also know that at the current generation, the number of individuals carrying the allele $A$, $N_{A}^{(t)}$, is equal to the frequency of $A$, multiplied by the total number of individuals in the population, that is $N_{A}^{(t)}=p^{(t)}N^{(t)}$. In a similar way, $N_{B}^{(t)}=(1-p^{(t)})N^{(t)}$. If we plug in these equivalences in the equation above, we get to the following one:

$$
\begin{aligned}
N^{(t+1)}&=N_{A}^{(t)}W_{A}^{(t)}+N_{B}^{(t)}W_{B}^{(t)} \\
N^{(t+1)}&=p^{(t)}N^{(t)}W_{A}^{(t)}+(1-p^{(t)})N^{(t)}W_{B}^{(t)}
\end{aligned}
$$

Further putting the $N^{(t)}$ that appears at the right-hand side in evidence leads to:

$$
\begin{aligned}
N^{(t+1)}&=p^{(t)}N^{(t)}W_{A}^{(t)}+(1-p^{(t)})N^{(t)}W_{B}^{(t)} \\
N^{(t+1)}&=N^{(t)}\left[p^{(t)}W_{A}^{(t)}+(1-p^{(t)})W_{B}^{(t)} \right] \\
N^{(t+1)}&=N^{(t)}\overline{W}^{(t)}
\end{aligned}
$$ where $\overline{W}^{(t)}=p^{(t)}W_{A}^{(t)}+(1-p^{(t)})W_{B}^{(t)}$ is the average fitness of the population.

$$\begin{aligned}
\frac{N_{A}^{(t+1)}}{N^{(t+1)}}&=\frac{N_{A}^{(t)}W_{A}^{(t)}}{N^{(t)}\overline{W}^{(t)}} \\
p^{(t+1)}&=\frac{p^{(t)}W_{A}^{(t)}}{\overline{W}^{(t)}}
\end{aligned}$$

Now, lets try to understand what the equation above is telling us: at the next generation, the frequency of the allele $A$ in the population will depend on the current frequency of $A$, multiplied by the fraction $\frac{W_{A}^{(t)}}{\overline{W}^{(t)}}$. This fraction represents the fitness of $A$ relative to the average fitness in the population. On the one hand, if the fitness of $A$ is larger than the average of the population, the fraction is higher than 1, and the frequency of $A$ will increase in the next generation. On the other hand, when $W_{A}^{(t)} < \overline{W}^{(t)}$, the fraction will be smaller than 1 and the frequency of $A$ will decrease. What the equation is describing makes complete sense. If individuals of $A$ reproduce more than the average, then, the frequency of $A$ increases. This is exactly the way that we expect natural selection to operate, but now, we are able to *quantify* this expected outcome.

### Wright's equation for the adaptive landscape of alleles

We can gain further insight about how selection drive the frequencies of alleles if we come up with an expression for the *change* in the frequency over generations, instead of just the frequency at the next generation. Mathematically, this is described by the difference $p^{(t+1)} - p^{(t)}$, or $\Delta p$ . Plugging in the expression for $p^{(t+1)}$ that we just derived leads to the following equation:

$$\begin{aligned}
\Delta p&=p^{(t+1)} - p^{(t)} \\
\Delta p&=\frac{p^{(t)}W_{A}^{(t)}}{\overline{W}^{(t)}} - p^{(t)} \\
\Delta p&=\frac{p^{(t)}W_{A}^{(t)}}{\overline{W}^{(t)}} - \frac{p^{(t)}\overline{W}^{(t)}}{\overline{W}^{(t)}} \\
\Delta p&=p^{(t)}\frac{\left(W_{A}^{(t)}-\overline{W}^{(t)}\right)}{\overline{W}^{(t)}}
\end{aligned}$$

Substituting $\overline{W}^{(t)}$ in the numerator with $p^{(t)}W_{A}^{(t)}+(1-p^{(t)})W_{B}^{(t)}$ leads to:

$$\begin{aligned}
\Delta p&=p^{(t)}\frac{\left[W_{A}^{(t)}-p^{(t)}W_{A}^{(t)}-(1-p^{(t)})W_{B}^{(t)}\right]}{\overline{W}^{(t)}} \\
\Delta p&=p^{(t)}\frac{\left[(1-p^{(t)})W_{A}^{(t)}-(1-p^{(t)})W_{B}^{(t)}\right]}{\overline{W}^{(t)}} \\
\Delta p&=p^{(t)}(1-p^{(t)})\frac{\left(W_{A}^{(t)}-W_{B}^{(t)}\right)}{\overline{W}^{(t)}}
\end{aligned}$$

This equation show that the change in the frequency of the $A$ allele depends on two components. First, it depends on $p^{(t)}(1-p^{(t)})$. This term is the product of the frequencies of $A$ and $B$, which, from probability theory, represents the variance in frequencies. From this interpretation, the term $p^{(t)}(1-p^{(t)})$ is the amount of genetic variance within the population. Second, the change in frequency also depends on the term $\frac{\left(W_{A}-W_{B}^{(t)}\right)}{\overline{W}^{(t)}}$, representing the difference in fitness between individuals carrying the $A$ or $B$ alleles. When $W_{A}>W_{B}$, this term is positive and it is negative when $W_{A}<W_{B}$. Therefore, the equation shows that selection drives evolutionary changes depending on the amount of the available genetic variance within the population and differences in fitness. On the one hand genetic variance scales the amount of evolutionary change that can occur, such that if there is no genetic variance, i.e., $p\neq 1$ and $p\neq 0$, no change occurs. On the other hand, differences in fitness control the direction of the evolutionary changes. Since the variance is always a positive number, when $W_{A}>W_{B}$, $\Delta p$ is also positive and the frequency of $p$ increases. In contrast, when $W_{A}<W_{B}$, $\Delta p$ will be negative and the frequency of $p$ decreases. If there are no differences in fitness, or $W_{A} = W_{B}$, there is no evolutionary change. Once more, this behavior makes complete sense from what we would expect from evolution by natural selection.

The equation above for the change in allele frequencies was the one derived by Sewall Wright in 1937 in the classic paper *The distribution of gene frequencies in populations*. The key idea of the paper was identifying that the term $\left(W_{A}^{(t)}-W_{B}^{(t)}\right)$ corresponds to the derivative of the average fitness of the population, relative to the frequency of allele $p$, as follows:

$$\begin{aligned}
\frac{\partial \overline{W}^{(t)}}{\partial p} &= \frac{\partial}{\partial p^{(t)}}p^{(t)}W_{A}^{(t)} + \frac{\partial}{\partial p^{(t)}}(1-p^{(t)})W_{B}^{(t)} \\
\frac{\partial \overline{W}^{(t)}}{\partial p^{(t)}} &=  W_{A}^{(t)} - W_{B}^{(t)}
\end{aligned}$$

This result holds whenever the *fitness* of alleles does not depend on their frequencies, or, in other words, when *fitness* is frequency independent. The result above allow us to rewrite the equation for the change in allele frequencies as follows:

$$
\Delta p=p^{(t)}(1-p^{(t)})\frac{\partial ln\overline{W}^{(t)}}{\partial p^{(t)}}
$$ where the *ln* term in $\frac{\partial ln\overline{W}^{(t)}}{\partial p^{(t)}}$ comes from the calculus rule that $\frac{1}{x}\frac{d}{dx} = \frac{dlnx}{dx}$.

Rewriting the equation in terms of this derivative is key to understand the concept of how natural selection drive adaptations in populations. A derivative represents the slope of a curve at a point. In turn, the average *fitness* of a population represents its growth rate. Thus, we can think about the derivative of the average fitness relative to the frequency of an allele as a population "climbing" a slope that is defined by the growth rate of the population. Visually this can be represented with the relationship between the average fitness of the population and the frequency of a given allele, as the figure below shows:

![Fig. 2 - Hypothetical example of the relationship between the average fitness of a population and the frequency of an allele (p). The dashed line represents the point at which the slope (the derivative) is equal to 0. In the points to the left of the dashed line, the slope is positive, and selection favors an increase in the frequency of the allele. In contrast, the slope is negative in the points to the right of the dashed line and selection favors a decrease in the frequency of the allele. Importantly, across all points selection will drive the frequencies of the allele in the direction at which the average fitness of the population increases.](figs/fig2.png){width="50%"}

$\\$

The figure above illustrates the concept introduced by Wright (1937) of an *adaptive landscape*. In evolutionary biology, the *adaptive landscape* depicts the relationship between the average fitness of a population and the values of traits, which, in our example, are the frequencies of alleles. From the figure and the interpretation of the derivative outlined above, we can see the natural selection will drive the evolution of allele frequencies in the direction that increases the average fitness of the population. This provides a mathematical formulation and proof of the intuitive concept of how natural selection favors *adaptations* in populations. This relationship always holds whenever *fitness* is frequency-independent, but not when *fitness* is frequency-dependent as we will see next in the exercise session.

Going back to our initial question: **how natural selection can drive changes in discrete or continuous traits in populations from one generation to the other?** Using Wright's equation we now can partially answer this question. For discrete traits, for instance, alleles, we learned that selection will favor the evolution of an increased frequency of alleles that maximize the average *fitness* of the population, leading to *adaptations*. The rate at which the population evolves will depend on the available genetic variation in the population, as well as how large are the differences in *fitness* between individuals carrying different alleles.

### References

Darwin, Charles Robert. 1861. *On the Origin of Species by Means of Natural Selection, or the Preservation of Favoured Races in the Struggle for Life*. 3d edition. London: John Murray.

Futuyma, Douglas. 2005. *Evolution*. Sunderland, MA: Sinauer Associates.

Levins, R. 1966. The strategy of model building in population biology. American Scientist 54 (4): 421--31.

Rice, Sean H. 2004. *Evolutionary Theory: Mathematical and Conceptual Foundations*. New York, NY: Oxford University Press.

Turner, Derek and Joyce C. Havstad. 2019. Philosophy of Macroevolution. *The Stanford Encyclopedia of Philosophy* (Summer 2019 Edition), Edward N. Zalta (ed.). Available in: <https://plato.stanford.edu/archives/sum2019/entries/macroevolution>.

Wright, S. 1937. The distribution of gene frequencies in populations. *Proceedings of the National Academy of Sciences of the United States of America* 23 (6): 307--20.

<!--chapter:end:01-intro.Rmd-->

# Exercise: Evolution of allele frequencies

## Simulating evolutionary changes in allele frequencies

In the first lecture we studied and derived the classical Wright's equation that predicts how natural selection can drive changes in the frequency of alleles over generations in a population. Throughout this exercise section, we will perform numerical simulations of this equation to gain more intuition about how evolution will proceed under different scenarios. We begin with the equation that we are trying to simulate:

$$
\Delta p=p^{(t)}(1-p^{(t)})\frac{\left(W_{A}^{(t)}-W_{B}^{(t)}\right)}{\overline{W}^{(t)}}
$$

Our first step is to define a vector that will store the frequencies, $p$ at each time step (generation) of the model, and an initial frequency of $p$, $p_{0}$. The choice of initial value is arbitrary and depends on your particular problem. Here we will start with $p_{0}=0.1$, but feel free to use and explore different values.

```{r}
dp = c()
p0 = 0.1
dp[1] = p0
```

Now, we need to code how $p$ gets updated at each time step. From the equation, $p$ gets updated depending on its value at the current time step, $t$, and the *fitness* of individuals carrying the alleles $A$ or $B$. So, we also need to define what are the fitness functions of these individuals. We will explore different scenarios, but we will begin with a constant value:

```{r}
wA = 2
wB = 1
```

Now, we need to iterate over the equation so that we can obtain the frequencies at future generations. To do so, we will first define for how many generations, $t_{max}$, we will run the simulation. Then, we will use a *for loop* to perform the iterations. In the *for loop* we will go through the following steps:

1.  Set the value of $p$ to the one at the current time step, $t$

2.  Compute the average fitness of the population as $pW_{A}+(1-p)W_{B}$

3.  Update the value of $p$ using Wright's equation

These steps are highlighted in the block of code below:

```{r}
tmax = 50 # The simulation will run for 50 generations

for(t in 1:(tmax-1)){ #Setting up the for loop
  
  p = dp[t] # Step 1
  w_avg = p*wA + (1-p)*wB #Step 2
  dp[t+1]= p + (p*(1-p)*(wA-wB)/w_avg) #Step 3
}
```

That is it! We have performed our first numerical simulation. Now that we have the outcome along generations, we can plot the results. To plot the results, we first set up a data frame with columns containing the outcome on our variable of interest. This variable is called a *state variable* and here it is the frequency of $p$ over the 50 generations of the population. With the data frame set up, we can plot how the *state variable* (on the y-axis) changes over the generations (x-axis). You can use a plot method of your choice. Here we are going to use the package *ggplot2* for all of the plots. The code to perform the steps above can be found below:

```{r, out.width="65%", out.height="65%"}
library(ggplot2)
library(ggpubr)

r = data.frame(dp=dp, t=1:tmax)

ggplot()+
  geom_line(data=r, aes(x=t, y=dp))+
  xlab("Generation")+ylab("Frequency of allele A")+
  theme_pubr()
```

Now that we have the code to perform the numerical simulations, it is convenient to put everything inside a function. For this example, our function will take as input arguments $t_{max}$, $W_{A}$, $W_{B}$ and the initial frequency of allele A in the population, $p_{0}$. Then, the function will run the simulation and return a data frame containing the different values of $p$ over the $t_{max}$ generations of the simulation. The code of the implement the function is as follows:

```{r, out.width="65%", out.height="65%"}
evo_simulation<-function(tmax, p0, wA, wB){ #Defining the function and the input arguments
  
  dp = c() #Creating the vector to store the outcome
  dp[1]<-p0 #Setting the initial frequency of p
  
  for(t in 1:(tmax-1)){ #Setting up the for loop
  
  p = dp[t] # Step 1
  w_avg = p*wA + (1-p)*wB #Step 2
  dp[t+1]= p + (p*(1-p)*(wA-wB)/w_avg) #Step 3
}
  
  r = data.frame(dp=dp, t=1:tmax) # Building the data frame
  
  return(r)
  
}

# Running the function to test it:

r = evo_simulation(tmax=50, p0=0.2, wA=2, wB=1)

# Plotting the result

ggplot()+
  geom_line(data=r, aes(x=t, y=dp))+
  xlab("Generation")+ylab("Frequency of allele A")+
  theme_pubr()
```

Now that we have a function that makes it very easy to simulate the changes in allele frequencies, try to explore how different values of $p_{0}$, $W_{A}$ and $W_{B}$ affect the evolutionary dynamics. Try to also explore how different values of $t_{max}$, or the time scale that we are looking at, can change our perception about how evolution is unfolding in a population.

## Using different assumptions for the fitness of alleles A and B

In the previous section we simulated the evolutionary dynamics of allele frequencies when the fitness of individuals carrying either one of the alleles are constant values. However, what would happen when fitness can change over time? Now, we will explore the evolutionary dynamics when $W_{A}$ and $W_{B}$ depends not only on constant value but also can vary with the frequency of allele $A$ or $B$. This is the case mentioned in the lecture notes that correspond to frequency-dependent values of fitness. To understand how frequency-dependence can affect the outcome, we will assume that $W_{A}$ and $W_{B}$ have the same constant baseline value, but can decrease with the frequency of their corresponding allele. This can be represented with the following two equations:

$$\begin{align}
W_{A}^{(t)}&=1-\alpha p^{(t)} \\
W_{B}^{(t)}&=1-\beta (1-p^{(t)})
\end{align}$$

where $\alpha$ and $\beta$ weight how much $W_{A}$ and $W_{B}$ is decreased depending on the frequency of alleles $A$ and $B$, respectively. Since it does not make biological sense to have negative fitness values, we just need to choose the values of $\alpha$ and $\beta$ so that fitness is never negative. Under this assumption, we can now build a now function that take as input arguments the *parameters* $\alpha$ and $\beta$, instead of the constant values of $W_{A}$ and $W_{B}$. The difference is that because fitness can vary across time, at each time step of the model we need to recompute fitness values. The code for the modified function is depicted below:

```{r, out.width="65%", out.height="65%"}
evo_simulation<-function(tmax, p0, alpha, beta){ #Defining the function and the input arguments
  
  dp = c() #Creating the vector to store the outcome
  dp[1]<-p0 #Setting the initial frequency of p
  
  for(t in 1:(tmax-1)){ #Setting up the for loop
  
  p = dp[t] # Setting current frequency
  wA = 1-(alpha*p) #Computing the fitness of A at the current generation
  wB = 1-(beta*(1-p)) #Computing the fitness of B at the current generation
  w_avg = p*wA + (1-p)*wB #Computing the average fitness of the population
  dp[t+1]= p + (p*(1-p)*(wA-wB)/w_avg) #Updating frequencies
}
  
  r = data.frame(dp=dp, t=1:tmax) # Building the data frame
  
  return(r)
  
}

# Running the function to test it:

r = evo_simulation(tmax=50, p0=0.2, alpha=0.1, beta=0.2)

# Plotting the result

ggplot()+
  geom_line(data=r, aes(x=t, y=dp))+
  xlab("Generation")+ylab("Frequency of allele A")+
  scale_y_continuous(limits=c(0,1))+ #Setting the limits on the y-axis to be the same as in the previous model
  theme_pubr()
```

With this new function, explore how different values of $\alpha$, $\beta$ and $p_{0}$ change the outcome. In your exploration, try to answer the following questions:

1.  How frequency-dependence changes the outcome of the evolutionary dynamics?

2.  Does the initial value of allele frequency in the population affect the final outcome?

3.  What is the role of $\alpha$ and $\beta$ in the outcome of the dynamics?

4.  What would be an ecological mechanism that can lead to the type of frequency dependence that we are exploring? What ecological pattern would you expect under this mechanism over the generations of a population?

## Simulating Wright's adaptive landscape

Until now we have explored the evolutionary dynamics of allele frequencies a population under different assumptions of the fitness of individuals carrying these alleles. In the lecture notes we saw that the evolutionary dynamics of these alleles can be visualized as populations embedded in a fitness landscape, depicting the relationship between the average fitness of a population and trait values. We also studied that the direction and magnitude of the evolutionary change is given by the slope in this landscape at a particular point of allele frequency. Here, we will explore how we can visualize the fitness landscape of the populations and how the populations move across this landscape along the evolutionary dynamics. In our example, the fitness landscape depicts the relationship between the average fitness of the population and the frequency of one allele. Therefore, to build this landscape we need to simulate what would be the average fitness of a population for many different values of allele frequency. To do so, we will perform the following steps:

1.  Define the fitness of alleles $A$ and $B$

2.  Build a vector containing many different values of $p$, varying from 0 to 1.

3.  Compute the average fitness of the population, $\overline{W}$, for each of these values of $p$.

4.  Plot and visualize the fitness landscape.

We will begin with constant fitness values, and then, will explore how the landscape changes with frequency-dependent fitness values. These three steps are implemented and highlighted in the code below:

```{r, out.width="65%", out.height="65%"}
wA = 2 # Step 1
wB = 1 # Step 1
p = seq(0, 1, 0.001) # Step 2
w_avg = p*wA + (1-p)*wB #Step 3

land = data.frame(p, w_avg) #Building a data frame with values of p and the corresponding average fitness

# Plotting the landscape.

ggplot()+
  geom_line(data=land, aes(x=p, y=w_avg))+
  xlab("Frequency of allele A")+ylab("Average fitness of the population")+
  theme_pubr()
```

Well, this landscape resembles much more a "ladder" than a proper landscape. However, this makes complete sense when we think about the relationship between $\overline{W}$ and $p$ when fitness are constant values. In fact, we can understand this relationship better with the equation for $\overline{W}$ as a function of $p$, as follows:

$$\begin{aligned}
\overline{W}^{(t)}&=p^{(t)}W_{A} + (1-p^{(t)})W_{B} \\
\overline{W}^{(t)}&=p^{(t)}W_{A} + W_{B} - p^{(t)}W_{B}
\overline{W}^{(t)}&=W_{B}+(W_{A}-W_{B})p^{(t)}
\end{aligned}$$

The equation above shows that the relationship between $\overline{W}$ and $p$ is the equation of a line. The line has intercept equal to $W_{B}$ and slope equal to $(W_{A}-W_{B})$. It is this slope that will determine the direction of evolutionary change. Now that we know how to build the landscape under a fitness function, we can also visualize how populations move in this landscape. We first build the landscape. Then, we use our function to simulate the evolutionary dynamics and plot the position of our population in the landscape in different generations. It is easier if we put everything inside a single function as we can find below:

```{r, out.width="65%", out.height="65%"}

library(viridis)

evo_landscape<-function(tmax, p0, wA, wB){ #Defining the function and the input arguments
  
p_theo = seq(0, 1, 0.001) # Defining the theoretical values of p to build the fitness landscape
w_avg_theo = p_theo*wA + (1-p_theo)*wB #Computing the average fitness
land = data.frame(p_theo, w_avg_theo) #Building a data frame with values of p and the corresponding average fitness
  
dp = c() #Creating the vector to store the outcome
dw = c() #Creating a vector to keep track of the average fitness along the evolutionary dynamics
dp[1]<-p0 #Setting the initial frequency of p
  
  for(t in 1:(tmax-1)){ #Setting up the for loop
  
  p = dp[t] # Setting current frequencies
  w_avg = p*wA + (1-p)*wB # Computing average fitness
  dw[t] = w_avg
  dp[t+1]= p + (p*(1-p)*(wA-wB)/w_avg) #Updating frequency values
  
}
  dw[tmax] =  dp[tmax]*wA + (1-dp[tmax])*wB #Computing average fitness for the final time step
  r = data.frame(dp=dp, dw, t=1:tmax) # Building the data frame
  
  return(list(land, r)) # Returning a list with the data frame of the dynamics and the landscape, respectively
  
}
# Running the function to test it:

r_list = evo_landscape(tmax=20, p0=0.2, wA=1.5, wB=1)

# Plotting the landscape and how the population moves over generations

ggplot()+
  geom_line(data=r_list[[1]], aes(x=p_theo, y=w_avg_theo))+
  geom_point(data=r_list[[2]], aes(x=dp, y=dw, fill=t), color="black", shape=21, size=3)+
  scale_fill_gradientn(colors=c("white", "black"))+
  labs(fill="Generation")+
  xlab("Frequency of allele A")+ylab("Average fitness of the population")+
  theme_pubr()
```

From the figure above we can visualize the result that we obtained from Wright's equation: when fitness is frequency independent, evolution by natural selection favors adaptations and increases the average fitness of a population. But what about when fitness is frequency-dependent? As we did before, we can adapt our code to incorporate different assumptions about fitness. For instance, we could build the fitness landscape for the same scenario that we already simulated, where fitness can decrease depending on the frequency of the alleles with a strength of $\alpha$ and $\beta$. The code below simulates this scenario and build the fitness landscape of the population.

```{r, out.width="65%", out.height="65%"}
evo_landscape<-function(tmax, p0, alpha, beta){ #Defining the function and the input arguments
  
p_theo = seq(0, 1, 0.001) # Defining the theoretical values of p to build the fitness landscape
wA_theo = 1 - (alpha*p_theo) # Defining the fitness function of A
wB_theo = 1 - (beta*(1-p_theo)) # Defining the fitness function of A
w_avg_theo = p_theo*wA_theo + (1-p_theo)*wB_theo #Computing the average fitness
land = data.frame(p_theo, w_avg_theo) #Building a data frame with values of p and the corresponding average fitness
  
dp = c() #Creating the vector to store the outcome
dw = c() #Creating a vector to keep track of the average fitness along the evolutionary dynamics
dp[1]<-p0 #Setting the initial frequency of p
  
  for(t in 1:(tmax-1)){ #Setting up the for loop
  
  p = dp[t] # Setting current frequencies
  wA = 1-(alpha*p) #Computing the fitness of A at the current generation
  wB = 1-(beta*(1-p)) #Computing the fitness of B at the current generation
  w_avg = p*wA + (1-p)*wB # Computing average fitness
  dw[t] = w_avg
  dp[t+1]= p + (p*(1-p)*(wA-wB)/w_avg) #Updating frequency values
  
}
  dw[tmax] =  dp[tmax]*wA + (1-dp[tmax])*wB #Computing average fitness for the final time step
  r = data.frame(dp=dp, dw, t=1:tmax) # Building the data frame
  
  return(list(land, r)) # Returning a list with the data frame of the dynamics and the landscape, respectively
  
}

# Running the function:

r_list = evo_landscape(tmax=50, p0=0.2, alpha=0.1, beta=0.2)

# Plotting the landscape and how the population moves over generations

ggplot()+
  geom_line(data=r_list[[1]], aes(x=p_theo, y=w_avg_theo))+
  geom_point(data=r_list[[2]], aes(x=dp, y=dw, fill=t), color="black", shape=21, size=3)+
  scale_fill_gradientn(colors=c("white", "black"))+
  labs(fill="Generation")+
  xlab("Frequency of allele A")+ylab("Average fitness of the population")+
  theme_pubr()
```

Using this new function, explore how different values of $\alpha$ and $\beta$ change the shape of the landscape. Try to answer the following questions:

1. How the fitness landscape changes when fitness is a frequency-independent versus frequency-dependent?
2. How the values of $\alpha$ and $\beta$ modify the shape of the fitness landscape?
3. Challenge: similar to how we did it for frequency-independent fitness values, try to interpret the shape of the landscape in terms of the equation of $\overline{W}$ as a function of $p$.

<!--chapter:end:02-ex1.Rmd-->

# Exercise: Simulating evolution using the Price theorem

## Simulating evolutionary changes in allele frequencies

In our second lecture we studied and derived the Price theorem (Price 1970) that can be used to predict how the mean value of any measurable property of a population change from one generation to the other. For this exercise section, we will use the Price theorem to gain more intuition about how the moments of the distribution of traits in a population can evolve by natural selection. Building upon the core results of the theorem, We will also study how we can predict the mode of selection in a population (directional, stabilizing and disruptive) using linear regressions.

We begin with the Price theorem, that can be expressed as the following equation (Rice 2005):

$$
\Delta \overline{z}=\frac{1}{\overline{W}}\left[Cov(W, z) + E(W\overline{\delta}) \right]
$$ As we studied during the lecture, the equation is comprised of two terms. The first term, $\frac{1}{\overline{W}}Cov(W, z)$ encompass the changes due to differential survival and reproduction, while the second one, comprises changes resulting from any process involved in reproduction. For this exercise section we will assume that $E(W\overline{\delta})=0$ and will work with the simplified version of the Price theorem, $\Delta \overline{z}=\frac{1}{\overline{W}}Cov(W, z)$.

We begin simulating a measurable trait, $z$, that follows a normal distribution with mean $\mu=5.0$ and $\sigma^2=1.0$ in a population of 10000 individuals:

```{r, out.width="65%", out.height="65%"}

library(ggplot2)
library(ggpubr)

n=10000 #Population size
z_u=5 #Mean trait value
z_var=1 #Variance
z = rnorm(n, mean=z_u, sd=sqrt(z_var)) #Sampling from a normal distribution with mean=5 and variance=1 (the standard deviation is equal to the square root of the variance).

# Plotting the distribution
ggplot(data=data.frame(z))+
  geom_density(aes(x=z))+
  xlab("Trait value")+ylab("Density")+
  theme_pubr()

```

Now that we have a distribution of traits, we can begin to use the Price theorem to predict how the moments of this distribution can change because of differential survival and reproduction. Here we will focus on the first and second moments of the distribution - the mean and the variance - but the theorem can also be used for other higher order moments. As examples, we will use three different types of functions for how the fitness of individuals vary with trait values: (1) $W=1+c+\epsilon$; (2) $W=1+\beta z +\epsilon$ (3) $W=e^{-\alpha\left(\theta-z+\epsilon\right)^2}$; where $c$ is a constant; $\beta$, $\alpha$ and $\theta$ are parameters that control the shape of the functions; and $\epsilon$ is a small amount of random noise that we will sample from a normal distribution. In the code block below we define these functions.

```{r, out.width="65%", out.height="65%"}

#Defining the parameters of the fitness functions:

e=rnorm(n, mean=0, sd=0.05) #Sampling random noise
c=1 # Parameter of fitness function (1)
beta=0.5 # Parameter of fitness functions (2)
alpha=0.5; theta=4.0 # Parameters of fitness function (3)

w1=1+c+e #Fitness function (1)
w2=1+beta*z+e #Fitness function (2)
w3=1+exp(-alpha*(theta-z+e)^2) #Fitness function (3)

```

Now that we have trait values and their corresponding fitness, we can use Price's theorem to predict the change in the mean and variance of the trait distribution from one generation to the other. For the mean, we need to compute the covariance between trait values and fitness, $Cov(W,z)$, while for the variance, we need to compute the covariance between fitness and the squared deviation of trait values to the mean, $Cov\left[W, (z-\overline{z})^2\right]$. Then, we divide the two covariances by the average fitness of the population, $\overline{W}$. Finally, we can plot the new distribution on top of the old one. The code to perform these steps for the fitness function $W=1+c+\epsilon$ is as follows:

```{r, out.width="65%", out.height="65%"}

delta_z=cov(w1,z)/mean(w1) #Change in the mean of z
delta_zvar=cov(w1,(z-mean(z))^2)/mean(w1) #Change in the variance of z

# Getting new distribution of trait values

z_new=rnorm(n, mean=z_u+delta_z, sd=sqrt(z_var+delta_z))

ggplot(data=data.frame(z=z, z_new=z_new))+
  geom_density(aes(x=z), linetype="dashed")+
  geom_density(aes(x=z_new))+
  xlab("Trait value")+ylab("Counts")+
  theme_pubr()

```

In the figure above, the dashed line represent the previous trait distribution, while the solid line the new one. The distributions look pretty much the same and the change in the mean and variance of the distribution of trait values is negligible. Considering the fitness function $W=1+c+\epsilon$, try to explain why there was no change in the distribution. Use the code above to predict how the distribution changes for the other two fitness functions. What differences can you observe?

## The regression of fitness on phenotypes and the modes of selection

Now that we know how to compute the change in the mean and variance of the distribution of traits in a population, we can try to gain intuition about the different modes of selection. To do so, we will use the two remaining fitness functions, $W=1+\beta z +\epsilon$ and $W=e^{-\alpha\left(\theta-z\right)^2+\epsilon}$. In the lecture we studied that the Price theorem can be rewritten as a regression of fitness on trait values, as follows:

$$
\Delta \overline{z}=\frac{1}{\overline{W}}\beta_{(W,z)} Var(z)
$$ From the above equation, we can study how natural selection drives the evolution of the mean and the variance of trait values with the corresponding regression coefficients. These regression coefficients can be computed from the covariances and variances as $\beta_{(W,z)}=\frac{Cov(W,z)}{Var(z)}$. When the trait itself is $(z-\overline{z})^2$, the regression coefficient can be computed as $\beta_{\left[W,(z-\overline{z})^2\right]}=\frac{Cov\left[W,(z-\overline{z})^2\right]}{Var\left[(z-\overline{z})^2\right]}$. When the regression coefficient of fitness on the trait $z$ is non zero, the trait is under *directional selection*. Similarly, if the regression coefficient of fitness on $(z-\overline{z})^2$ is non zero, the trait is either under *stabilizing selection* ($\beta_{\left[W,(z-\overline{z})^2\right]}<0$) or *disruptive selection* ($\beta_{\left[W,(z-\overline{z})^2\right]}>0$). For the fitness functions that we are going to use in this part of the exercise section, we can visually assess the modes of selection acting on trait $z$. The code to do so is reproduced below:

```{r, out.width="65%", out.height="65%"}

library(patchwork)

# Creating a data frame with variables z, the squared deviations of z to the mean, and the fitness of individuals in the population when using fitness functions (2) and (3)

z_df = data.frame(z=z, z2=(z-mean(z))^2, w2=w2, w3=w3)

# Creating plots with the regression between z and w2, as well as (z-mean(z))^2 for w2

p1 = ggplot(data=z_df, aes(x=z, y=w2))+
  geom_point()+
  xlab("Trait values")+ylab("Fitness (function #2)")+
  geom_smooth(method="lm", se=F)+
  theme_pubr()

p2 = ggplot(data=z_df, aes(x=z2, y=w2))+
  geom_point()+
  xlab("Squared deviation of trait values to the mean")+ylab("Fitness (function #2)")+
  geom_smooth(method="lm", se=F)+
  theme_pubr()

# Creating plots with the regression between z and w2, as well as (z-mean(z))^2 for w3

p3 = ggplot(data=z_df, aes(x=z, y=w3))+
  geom_point()+
  xlab("Trait values")+ylab("Fitness (function #3)")+
  geom_smooth(method="lm", se=F)+
  theme_pubr()

p4 = ggplot(data=z_df, aes(x=z2, y=w3))+
  geom_point()+
  xlab("Squared deviation of trait values to the mean")+ylab("Fitness (function #3)")+
  geom_smooth(method="lm", se=F)+
  theme_pubr()

# Combining all plots using the patchwork package

p1+p2+p3+p4 + plot_annotation(tag_levels=c("a"))

```

From the plots above, try to answer the following questions:

1.  What are the modes of selection for the fitness functions (2) and (3)?
2.  What would be a possible biological interpretation of the parameter $\theta$ in the fitness function $W=e^{-\alpha\left(\theta-z+\epsilon\right)^2}$?
3.  Try changing both $\theta$ (e.g. to $\theta=6.0$ instead of $\theta=4.0$) and $\alpha$. How these parameters change the relationship between fitness, trait values, and the regression coefficients?

<!--chapter:end:03-ex2.Rmd-->

# Exercise: Simulating evolution using Lande's equation

## Simulating evolutionary changes in continuous traits

Our third lecture introduced the classical equation in quantitative genetics derived by [Russel Lande (1976)](https://onlinelibrary.wiley.com/doi/10.1111/j.1558-5646.1976.tb00911.x). After studying and going through the steps to derive this equation, here we will use it to simulate evolutionary changes in continuously varying traits. Lande's equation relates how the mean value of a continuous trait in a population ($\overline{z}$) changes from one generation to the other in response to the available variance of the trait in the population ($\sigma^{2}_{z}$), its heritability, $h^2$, and direction and intensity of natural selection. The direction and intensity of selection on the trait is mathematically described by the selection gradient, $\frac{\partial ln\overline{W}}{\partial \overline{z}}$. These two components underly Lande's equation and can be used to predict evolutionary changes in $\overline{z}$ as follows:

$$
\Delta \overline{z}=h^2 \sigma^{2}_{z}\frac{\partial ln\overline{W}}{\partial \overline{z}}
$$

There are two main approaches that we can use to model evolutionary changes using Lande's equation. For the first one, our starting point is a function describing how the fitness of individuals vary with trait values. We next use this function to derive a new one, describing how the mean fitness of the population depends on the mean values of traits. Finally, we derive the selection gradient which can then, be plugged in into Lande's equation. The second approach is directly assuming a function for the selection gradient. Here, we will use the first approach, but we will also see how to use the second one in block 2 of the course.

Thus, our first step is to define a function, $W(z)$, describing how fitness of individuals vary with trait values. We will use the two fitness functions that are similar to the ones used in the previous exercise section, as follows:

$$\begin{align}
W_{1}(z) &= 1+\beta z \\
W_{2}(z) &= e^{-\alpha\left(\theta-z\right)^2}
\end{align}$$

We now need to derive how mean fitness changes relative to mean trait values. To do so, we need to compute the expected value of the fitness function of individuals. For linear functions of random variable, such as $W_{1}(z)$, computing an expected value is straightforward because of two identities: $E[aX]=aE[X]$ and $E[X+b]=E[X]+b$. For our function $W_{1}(z)$, we can apply these two identities as follows:

$$
E[1+\beta z] = 1+E[\beta z]=1+\beta E[z]=1+\beta \overline{z}
$$ where we used the equivalence $E[z]=\overline{z}$ just to simplify the notation. For the second fitness function, $W_{2}(z)$, we need to rely on an approximation to compute the expected value. When $z$ is normally distributed (as it needs to be when applying Lande's equation), with small values of $\alpha$ or variance, $\sigma^2$, we can approximate this expectation as follows:

$$
E[e^{-\alpha\left(\theta-z\right)^2}] \approx e^{-\alpha\left[\left(\theta-\overline{z}\right)^2 + \sigma^2\right]}
$$

We will not cover the approximation in the course, but it comes from how we can approximate $E[ln f(X)]$ as $lnE[f(X)]$ under the assumptions mentioned above ([Barton 1986](https://pubmed.ncbi.nlm.nih.gov/3744046/)).

Our last step is to derive the selection gradient. For that we need to apply the natural logarithm to the functions above and compute their derivatives relative to the mean trait value. Computing derivatives is very straightforward when you are familiar with all of the rules. If you are not familiar with computing derivatives, we can do it using the function D() in R. To use this R function, we just need to define an expression and the variable that we wish to compute the derivative in that expression. The code to do so for the fitness function $\overline{W}_{1}(\overline{z})$ is as follows:

```{r, out.width="65%", out.height="65%"}

dw1=D(expression(log(1+beta*z)), "z")
print(dw1)

```

As you can see, the derivative is equal to $\frac{\beta}{1+\beta \overline{z}}$. We can repeat the same process for second fitness function, $e^{-\alpha\left[\left(\theta-\overline{z}\right)^2 + \sigma^2\right]}$. Since we are computing the derivative of the natural logarithm of this function, we can simplify it as $lnW_{2}(\overline{z})=-\alpha\left[\left(\theta-\overline{z}\right)^2 + \sigma^2\right]$ and use the simplified function to compute the derivative, as follows:

```{r, out.width="65%", out.height="65%"}

dw2=D(expression(-a*((theta-z)^2+v)), "z") #v here corresponds to the variance in the equation
print(dw2)

```

which evaluates to $2\alpha (\theta-\overline{z})$. Now we have everything that we need to model how the mean value of the trait, $\overline{z}$, changes over generations in the population. We will begin with how $\overline{z}$ changes when we use the first fitness function. Plugging the selection gradient that we computed above for this fitness function in Lande's equation, the equation that we need to iterate over is the following one:

$$
\overline{z}^{(t+1)}=\overline{z}^{(t)}+ h^2 \sigma^{2}_{z}\frac{\beta}{1+\beta \overline{z}^{(t)}}
$$

Thus, as we did in the first exercise section, we need to define:

1.  A vector that will store trait values over time.
2.  The initial trait value in the population.
3.  The parameters of the model, such as the number of generations that we will simulate, $t_{max}$, $\beta$, $\sigma^{2}_{z}$ and $h^2$.

Then, after defining all of the parameters we iterate over the equation using a for loop. The code to perform these steps are as follows:

```{r}
dz = c() #Defining vector to store trait values over time
z0 = 1 #Defining initial trait value in the population
dz[1] = z0 #Defining initial trait value in the population

tmax=100 # Number of generations
varz=0.1 # Phenotypic variance
h = 0.1 # Heritability
beta=0.5 #Parameter beta

for(t in 1:(tmax-1)){ #Setting up the for loop
  
  z = dz[t] # Setting current trait values
  dlnw = (beta/(1+beta*z))  #Computing the selection gradient of fitness function 1
  dz[t+1]= z + h*varz*dlnw #Updating trait values using Lande's equation
  
}

```

Now, as we did before, we can put the above code inside a function to make it easier to explore the simulations and plot the results.

```{r, out.width="65%", out.height="65%"}

library(ggplot2)
library(ggpubr)

evo_simulation<-function(tmax, z0, varz, h, beta){

dz = c() #Defining vector to store trait values over time
dz[1] = z0 #Defining initial trait value in the population

for(t in 1:(tmax-1)){ #Setting up the for loop
  
  z = dz[t] # Setting current trait values
  dlnw = (beta/(1+beta*z))  #Computing the selection gradient of fitness function 1
  dz[t+1]= z + h*varz*dlnw #Updating trait values using Lande's equation
  
}

r = data.frame(dz=dz, t=1:tmax) # Building the data frame with trait values over time
  
return(r)

}

# Running the function to test it:

r = evo_simulation(tmax=100, z0=1, h=0.1, varz=0.1, beta=0.5)

# Plotting the result

ggplot()+
  geom_line(data=r, aes(x=t, y=dz))+
  xlab("Generation")+ylab("Average trait value in the population")+
  theme_pubr()
```

Using the function above, explore how different parameter values change the outcome of the evolutionary dynamics. Try to think about why we have this outcome in face of the fitness function that we are using.

## Simulating the adaptive landscape of a continuous trait

Before proceeding to the second fitness function, we can gain more intuition about the outcome of the evolutionary dynamics when we visualize the fitness landscape of the trait. To do so, we will repeat a similar procedure to what we have already done in the first exercise section. We will go through the following steps:

1.  Build a vector containing many different values of $\overline{z}$.

2.  Compute the average fitness of the population, $\overline{W}$, for each of these values of $\overline{z}$ using the fitness function.

3.  Plot and visualize the fitness landscape.

```{r, out.width="65%", out.height="65%"}

beta=0.5 #Defining parameter beta
z = seq(0, 10, 0.001) # Step 1
w_avg = 1+beta*z #Step 2

land = data.frame(z, w_avg) #Building a data frame with values of p and the corresponding average fitness

# Plotting the landscape.

ggplot()+
  geom_line(data=land, aes(x=z, y=w_avg))+
  xlab("Average trait value in the population")+ylab("Average fitness of the population")+
  theme_pubr()
```

Now that we have the adaptive landscape, try to think about its shape and how evolution proceeds when we use the first fitness function. Your task for this section will be to adapt the code to simulate the evolutionary dynamics and the fitness landscape when we use the second fitness function, $e^{-\alpha\left[\left(\theta-\overline{z}\right)^2 + \sigma^2\right]}$. Use both the function and the selection gradient, $2\alpha (\theta-\overline{z})$, to simulate the adaptive landscape and the evolutionary dynamics of the trait. Try to answer the following questions:

1.  For both fitness functions, is there and end point to the evolutionary dynamics? If it does so, what would be this end point?

2.  From the shape of the adaptive landscapes, could you predict how evolution would proceed in the population?

3.  What sources of selective pressures and biological mechanisms could lead to these two adaptive landscapes and their underlying evolutionary dynamics?

<!--chapter:end:04-ex3.Rmd-->

# Exercise: Simulating coevolution mediated by a gene-for-gene or matching allele mechanisms

## Simulating coevolution of victim-exploiter interactions

In first lecture of the second block we studied how we can use Wright's equation to model the gene-for-gene or matching allele coevolution of two interacting species. Particularly, we studied the example in which one of the species is an exploiter and benefit from the interaction, while the other is a victim that is negatively affected by the interaction. Here, we will perform numerical simulations of this coevolutionary model to gain intuition about how different assumptions about the mechanism of coevolution and types of interaction can change the outcome of the coevolutionary dynamics. We will begin with the gene-for-gene model with one exploiter and one victim species. In this model, we assumed that the interaction between a victim and exploiter depends on two components. First, it depends on a matrix describing how individuals carrying alleles $A_{x}$ or $B_{x}$ of the victim species are affected by the individuals carrying alleles $A_{y}$ or $B_{y}$ of the exploiter species:

::: math
$$
\begin{array}{cc} &
\begin{array}{cc} A_{y} && B_{y} \end{array}
\\
\begin{array}{cc}
A_{x} \\
B_{x} \end{array}
&
\left(
\begin{array}{cc}
\alpha_{AxAy} & \alpha_{AxBy} \\
\alpha_{BxAy} & \alpha_{BxBy} \end{array}
\right)\end{array}
$$
:::

Second, it depends on the frequency of individuals carrying alleles $A$ and $B$ in the populations of the victim - $p_{x}$ and $(1-p_{x})$ - and exploiter species - $p_{y}$ and $(1-p_{y})$. Using these two components, the fitness consequences of ecological interactions for the individuals of the victim and exploiter species carrying either the $A$ or $B$ alleles are given by the following set of equations:

$$\begin{aligned}
W_{A,x}&=1-s_{x}\left[\alpha_{AxAy}p_{y}+\alpha_{AxBy}(1-p_{y})\right] \\
W_{B,x}&=1-s_{x}\left[\alpha_{BxAy}p_{y}+\alpha_{BxBy}(1-p_{y})\right] \\
W_{A,y}&=1+s_{y}\left[\alpha_{AyAx}p_{x}+\alpha_{AyBx}(1-p_{x})\right] \\
W_{B,y}&=1+s_{y}\left[\alpha_{ByAx}p_{x}+\alpha_{ByBx}(1-p_{x})\right] \\
\end{aligned}$$

where $s_{x}$ and $s_{y}$ are parameters that scale how strongly interactions affect fitness. Then, we can plug in these fitness functions into Wright's equation to obtain the recursive ones describing how the frequency of alleles change in both the victim and exploiter populations, as follows:

$$\begin{aligned}
p_{x}^{(t+1)}&=p_{x}^{(t)}+p_{x}^{(t)}(1-p_{x}^{(t)})\frac{\left(W_{A,x}^{(t)}-W_{B,x}^{(t)}\right)}{\overline{W}_{x}^{(t)}} \\
p_{y}^{(t+1)}&=p_{y}^{(t)}+p_{y}^{(t)}(1-p_{y}^{(t)})\frac{\left(W_{A,y}^{(t)}-W_{B,y}^{(t)}\right)}{\overline{W}_{y}^{(t)}}\end{aligned}$$

In the lecture, we substituted the values of fitness in the equation above using the assumptions that coevolution is mediated by a gene-for-gene mechanism. Here there is no need to do this, since it will be more convenient to directly implement the equations above in the simulation. To perform the numerical simulations we will follow the same steps as in the first exercise section, the only difference being that now we have two coupled equations. Once more, we will set up a *for loop* to iterate over the equations and will go through the following steps:

1.  Define a function that takes as input parameters of the model, such as the matrix of effects, the maximum number of time steps of the model, and initial values of $p_{x}$ and $p_{y}$.

2.  In a for loop, set the value of $p_{x}$ and $p_{y}$ to the one at the current time step, $t$

3.  In a for loop, compute the average fitness of the populations as $p_{x}W_{A,x}+(1-p_{x})W_{B,x}$ and $p_{y}W_{A,y}+(1-p_{y})W_{B,y}$.

4.  In a for loop, update the values of $p_{x}$ and $p_{y}$ using Wright's equation and our assumptions about the fitness consequences of interactions.

5.  Return a data frame with the results.

These steps are highlighted in the block of code below:

```{r, out.width="65%", out.height="65%"}

# Step (1)

#Defining a function that takes as input the following parameters:

#A=Matrix of effects between alleles
#sx=Overall strength of ecological interactions on fitness of the victim species
#sy=Overall strength of ecological interactions on fitness of the exploiter species
#p0_x=Initial frequency of allele A of the victim species
#p0_y=Initial frequency of allele A of the exploiter

coevo<-function(A, sx, sy, tmax, p0_y, p0_x){ #Step (1)
  
x_dp = c() #Creating vector to store values of the frequency of allele A for the victim species
y_dp = c() #Creating vector to store values of the frequency of allele A for the exploiter species

x_dp[1] = p0_x #Setting initial frequency of allele A for the victim species
y_dp[1] = p0_y #Setting initial frequency of allele A for the exploiter species

#For loop to iterate over the equation
for(t in 1:(tmax-1)){
  
  # Step (2)
  
  xp = x_dp[t] #Setting current frequency of allele A for the victim species
  yp = y_dp[t] #Setting current frequency of allele A for the exploiter species
  
  # Step (3)

  x_wA = 1 - sx*(A[1,1]*yp + A[1,2]*(1-yp)) #Computing the fitness of allele A for the victim species
  x_wB = 1 - sx*(A[2,1]*yp + A[2,2]*(1-yp)) #Computing the fitness of allele B for the victim species
  x_avg_w = xp*x_wA + (1-xp)*x_wB #Computing the average fitness of the population of the victim species

  y_wA = 1 + sy*(A[1,1]*xp + A[2,1]*(1-xp)) #Computing the fitness of allele A for the exploiter species
  y_wB = 1 + sy*(A[1,2]*xp + A[2,2]*(1-xp)) #Computing the fitness of allele B for the exploiter species
  y_avg_w = yp*y_wA + (1-yp)*y_wB #Computing the average fitness of the population of the exploiter species
  
  # Step (4)
  
  x_dp[t+1]=xp + ((xp*(1-xp)*(x_wA-x_wB))/x_avg_w) #Using Wright's equaiton to compute frequency of A in the next generation for the victim species
  y_dp[t+1]=yp + ((yp*(1-yp)*(y_wA-y_wB))/y_avg_w) #Using Wright's equaiton to compute frequency of A in the next generation for the exploiter species
  
}

r=data.frame(x_dp, y_dp, t=1:tmax) # Step (5), creating a data frame with frequencies over time

return(r)
  
}

```

Now we have a function that simulate the coevolution of a victim and an exploiter species under any type of matrix of effects between alleles. Let's start simulating coevolution under a gene-for-gene mechanism. For the example of gene-for-gene coevolution that we studied in the lecture, the matrix takes the following form:

$$
\begin{array}{cc} &
\begin{array}{cc} A_{y} & B_{y} \end{array}
\\
\begin{array}{cc}
A_{x} \\
B_{x} \end{array}
&
\left(
\begin{array}{cc}
1 && 0 \\
1 && 1 \end{array}
\right)\end{array}
$$ 
Thus, we need to set up this matrix first, to pass it as an argument (the matrix $A$ in the code) to our function. The code to do so is as follows:

```{r, out.width="65%", out.height="65%"}

#Creating a 2x2 matrix with entries corresponding to the gene-for-gene one studied in the lecture

A=matrix(data=c(1,1,0,1), nrow=2, ncol=2)
rownames(A)=c("Ax", "Bx") #Changing row names to facilitate visualization
colnames(A)=c("Ay", "By") #Changing column names to facilitate visualization

A

```

Now that we have the matrix of effects set up, we can pass it as an argument to the function that we developed earlier, along with other parameter values of the model. Then, we can run the function, and plot the results.

```{r, out.width="65%", out.height="65%"}

#Running the coevolutionary model
r=coevo(A=A, sx=0.1, sy=0.1, tmax=100, p0_y=0.2, p0_x=0.2)

#Plotting the results

library(ggplot2)
library(ggpubr)

ggplot()+
  geom_line(data=r, aes(x=t, y=x_dp), color="royalblue3")+ # Frequency of allele A for victims, in blue
  geom_line(data=r, aes(x=t, y=y_dp), color="firebrick3")+ #Frequency of allele A for exploiters, in red
  xlab("Generations")+ylab("Frequency of allele A")+
  theme_pubr()

```

Using the function that simulates coevolution, try to explore how the coevolutionary dynamics changes under different parameter values. Try to answer the following questions:

1. How different values of $s_{x}$, $s_{y}$ and initial frequency of alleles modify the outcome of coevolution?
2. Under what situations coevolution erodes polymorphism from the victim's population?

## Simulating coevolution of antagonistic interactions under different assumptions

Until now we are assuming that a gene-for-gene mechanism underlies the coevolution of victims and exploiters. However, in some cases the interaction may also depend on the matching of alleles, as in the interaction between the small crustacean *Daphnia magna* and the bacteria *Pasteuria ramosa* (Luijckx *et al.* 2013). In this case, the matrix of effects takes the following form:

$$
\begin{array}{cc} &
\begin{array}{cc} A_{y} & B_{y} \end{array}
\\
\begin{array}{cc}
A_{x} \\
B_{x} \end{array}
&
\left(
\begin{array}{cc}
1 && 0 \\
0 && 1 \end{array}
\right)\end{array}
$$
Following our previous implementation, build this matrix in R and use it as an argument to simulate coevolution of a victim and an exploiter species under a matching allele mechanism. Plot the results and try to answer the following questions:

1. What differences can you observe between the coevolutionary dynamics under a gene-for-gene or a matching allele mechanism?

2. What would be a possible explanation for these differences?


## Simulating coevolution of mutualistic interactions

In the previous section, we simulated coevolution of one victim and exploiter species under two different mechanisms determining the outcome of the interaction, gene-for-gene or matching allele. Here, we will slightly modify this coevolutionary model to encompass mutualistic interactions. To do so, we need to modify our assumption about how interactions affect the fitness of species, and what is the interaction mechanism mediating this effect. Mutualisms are interactions that increase the fitness of individuals. In that case, the equations for the fitness of individuals carrying the alleles A or B of two mutualists, are as follows:

$$\begin{aligned}
W_{A,x}&=1+s_{x}\left[\alpha_{AxAy}p_{y}+\alpha_{AxBy}(1-p_{y})\right] \\
W_{B,x}&=1+s_{x}\left[\alpha_{BxAy}p_{y}+\alpha_{BxBy}(1-p_{y})\right] \\
W_{A,y}&=1+s_{y}\left[\alpha_{AyAx}p_{x}+\alpha_{AyBx}(1-p_{x})\right] \\
W_{B,y}&=1+s_{y}\left[\alpha_{ByAx}p_{x}+\alpha_{ByBx}(1-p_{x})\right] \\
\end{aligned}$$

Since, many mutualistic interactions are mediated by a trait matching mechanism, we model this mechanism using the matrix of effects of the matching allele model:

$$
\begin{array}{cc} &
\begin{array}{cc} A_{y} & B_{y} \end{array}
\\
\begin{array}{cc}
A_{x} \\
B_{x} \end{array}
&
\left(
\begin{array}{cc}
1 && 0 \\
0 && 1 \end{array}
\right)\end{array}
$$
For this section, your task will be to adapt the function that simulate coevolution to incorporate the fitness equations and the matrix of effects for mutualisms. Then, simulate the coevolutionary dynamics and try to answer the following question:

1. When mutualistic species coevolve, is it possible to maintain both alleles (i.e. polymorphism) in the populations?

2. What would be a possible biological mechanism that could change this outcome? Think about a mechanism that we could include as an additional assumption in the fitness of individuals of the mutualistic species.


<!--chapter:end:05-ex4.Rmd-->

# Exercise: Simulating coevolution mediated by a trait matching mechanism

## Simulating coevolution of species under victim-exploiter interactions

In our theoretical lecture we studied how we can use Lande's equation to model the coevolution of two species whose interaction depends on the matching of the traits of the species. Here, we will perform numerical simulations of this coevolutionary model to gain intuition about how coevolution can shape patterns of continuous traits in populations interacting species. In the lecture, we started with an example of victim-exploiter interaction, where the fitness of individuals of one of the species increase with interactions, but the fitness of individuals of the second species decrease. We will begin with this type of interaction. For interactions between a victim and an exploiter, we first assumed that the fitness of individuals of the victim species decreases when their traits, $z_x$, match the traits of individuals of the exploiter species, $z_y$. Similarly, we assumed that the fitness of individuals of the exploiter species increases the higher their trait matching with individuals of the victim one. Then, we approximated the mean fitness of the populations of the victim and exploiter species, as follows:

$$\begin{aligned}
\overline{W_x}(\overline{z_{x}}) &\approx 1-s_{x}e^{-\alpha[(\overline{z}_x-\overline{z}_y)^2+\sigma^2_{xy}]} \\
\overline{W_y}(\overline{z_{y}}) &\approx 1+s_{y}e^{-\alpha[(\overline{z}_x-\overline{z}_y)^2+\sigma^2_{xy}]}
\end{aligned}$$

where $\sigma^2_{xy}=\sigma^2_{x}+\sigma^2_{y}$ corresponds to the sum of the variance of the traits of the victim and exploiter species, respectively. Using these two functions for the mean fitness of the victim and exploiter species, we derived the two selection gradients, $\frac{\partial ln\overline{W_x}}{\partial \overline{z}_x}$ and $\frac{\partial ln\overline{W_y}}{\partial \overline{z}_y}$ underlying the two functions, as follows:

$$\begin{aligned}
\frac{\partial ln\overline{W_x}}{\partial \overline{z}_x} &= \frac{2\alpha s_{x}e^{-\alpha[(\overline{z}_x-\overline{z}_y)^2+\sigma^2_{xy}]}}{1-s_{x}e^{-\alpha[(\overline{z}_x-\overline{z}_y)^2+\sigma^2_{xy}]}}(\overline{z}_x-\overline{z}_y) \\
\frac{\partial ln\overline{W_y}}{\partial \overline{z}_y} &= \frac{2\alpha s_{y}e^{-\alpha[(\overline{z}_x-\overline{z}_y)^2+\sigma^2_{xy}]}}{1+s_{y}e^{-\alpha[(\overline{z}_x-\overline{z}_y)^2+\sigma^2_{xy}]}}(\overline{z}_x-\overline{z}_y)
\end{aligned}$$

As we did in the exercise section of Lande's equation, we can check or compute the derivatives corresponding to the selection gradient symbolically using R:

```{r, out.width="65%", out.height="65%"}

D(expression(log(1-sx*exp(-a*((zx-zy)^2 + var_xy)))), "zx")
D(expression(log(1+sy*exp(-a*((zx-zy)^2 + var_xy)))), "zy")

```

which we can see match the selection gradients that we computed for the victim and exploiter species.

With the selection gradients in hand, we just need to set up our numerical simulations. To perform the numerical simulations we will follow the same steps as in the exercise section where we simulated Lande's equation. The only difference being that now we have two coupled equations. Once more, we will set up a *for loop* to iterate over the equations and will go through the following steps:

1.  Define a function that takes as input parameters of the model. In our case these will be $s_{x}$, $s_{y}$, $\alpha$, $\sigma^2_{x}$, $\sigma^2_{y}$, $h^2$, the maximum number of time steps of the model ($t_{max}$), and initial values of $\overline{z}_{x}$ and $\overline{z}_{y}$.

2.  In a for loop, set the value of $\overline{z}_{x}$ and $\overline{z}_{y}$ to the one at the current time step, $t$

3.  Within this for loop, compute the selection gradient of the populations using the equations that we found.

4.  Still within the loop, update the values of $\overline{z}_{x}$ and $\overline{z}_{y}$ using Lande's equation and the selection gradients that we computed.

5.  Return a data frame with the results.

These steps are highlighted in the block of code below:

```{r, out.width="65%", out.height="65%"}

# Step (1)

#Defining a function that takes as input the following parameters:

#sx=Overall strength of ecological interactions on fitness of the victim species
#sy=Overall strength of ecological interactions on fitness of the exploiter species
#a=Parameter alpha of the model
#h=Heritability of the traits of both the victim and exploiter species (assumed to be equal)
#v_zx=Variance in the trait of the victim species
#z_vy=Variance in the trait of the exploiter species
#tmax=Maximum number of time steps (generations) of the simulation
#z0_x=Initial mean trait value of the population of the victim species
#z0_y=Initial mean trait value of the population of the exploiter species

coevo<-function(sx, sy, a, h, v_zx, v_zy, tmax, z0_x, z0_y){ #Step (1)
  
  dzx = c() #Creating vector to store values of the mean trait value of the population of the victim species 
  dzy = c() #Creating vector to store values of the mean trait value of the population of the exploiter species
  
  dzx[1] = z0_x #Setting initial mean trait value in the population of the victim species
  dzy[1] = z0_y #Setting initial mean trait value in the population of the exploiter species
  
  #For loop to iterate over the equation - here we will use Lande's equation
  for(t in 1:(tmax-1)){
    
    # Step (2)
    
    zx = dzx[t] #Setting the mean trait value at the current generation of the of the population of the victim species
    zy = dzy[t] #Setting the mean trait value at the current generation of the of the population of the exploiter species
    
    # Step (3)
    
    mx=sx*2*a*(exp(-a*((zx-zy)^2+v_zx+v_zy)))/(1-sx*exp(-a*((zx-zy)^2+v_zx+v_zy)))
    my=sy*2*a*(exp(-a*((zx-zy)^2+v_zx+v_zy)))/(1+sy*exp(-a*((zx-zy)^2+v_zx+v_zy)))
    
    dlnw1 = mx*(zx-zy)
    dlnw2 = my*(zx-zy)
    
    # Step (4)
    
    dzx[t+1]=zx + h*v_zx*dlnw1 #Using Lande's equation to compute mean trait value at the next generation of the population of the victim species
    dzy[t+1]=zy + h*v_zy*dlnw2 #Using Lande's equation to compute mean trait value at the next generation of the population of the exploiter species
    
  }
  
  r=data.frame(dzx, dzy, t=1:tmax) # Step (5), creating a data frame with mean trait values over time of the two species
  
  return(r)
  
}

```

Now we have a function that simulate the coevolution of a victim and an exploiter species when interactions are mediated by a trait matching mechanism. So, we can use this function and then visualize the results:

```{r, out.width="65%", out.height="65%"}

#Running the coevolutionary model
r=coevo(sx=0.1, sy=0.1, a=0.1, tmax=5000, z0_x=5, z0_y=1, h=0.5, v_zx=0.5, v_zy=0.5)

#Plotting the results

library(ggplot2)
library(ggpubr)

ggplot()+
  geom_line(data=r, aes(x=t, y=dzx), color="royalblue3")+ # Mean trait value for victims, in blue
  geom_line(data=r, aes(x=t, y=dzy), color="firebrick3")+ #Mean trait value for exploiters, in red
  xlab("Generations")+ylab("Mean trait value")+
  theme_pubr()

```

Using the function that simulates coevolution, try to explore how the coevolutionary dynamics changes under different parameter values. Try to answer the following question:

1.  How different values of $s_{x}$ and $s_{y}$ modify the outcome of coevolution?

2.  What would be a mechanism that could modify this outcome so that it is more similar to the dynamics for matching alleles that we simulated in the previous exercise section?

## Simulating the coevolution of mutualistic species

As we did with our coevolutionary model of morph/allele frequencies, we can modify the fitness functions to model mutualistic interactions. Here, the only modification that we need to perform is to change the negative sign to a positive sign for the effects of ecological interactions on the fitness of one of the species, as follows:

$$\begin{aligned}
\overline{W_x}(\overline{z_{x}}) &\approx 1+s_{x}e^{-\alpha[(\overline{z}_x-\overline{z}_y)^2+\sigma^2_{xy}]} \\
\overline{W_y}(\overline{z_{y}}) &\approx 1+s_{y}e^{-\alpha[(\overline{z}_x-\overline{z}_y)^2+\sigma^2_{xy}]}
\end{aligned}$$

These two expressions for the mean fitness of the species leads to the following selection gradients:

$$\begin{aligned}
\frac{\partial ln\overline{W_x}}{\partial \overline{z}_x} &= \frac{2\alpha s_{x}e^{-\alpha[(\overline{z}_x-\overline{z}_y)^2+\sigma^2_{xy}]}}{1+s_{x}e^{-\alpha[(\overline{z}_x-\overline{z}_y)^2+\sigma^2_{xy}]}}(\overline{z}_y-\overline{z}_x) \\
\frac{\partial ln\overline{W_y}}{\partial \overline{z}_y} &= \frac{2\alpha s_{y}e^{-\alpha[(\overline{z}_x-\overline{z}_y)^2+\sigma^2_{xy}]}}{1+s_{y}e^{-\alpha[(\overline{z}_x-\overline{z}_y)^2+\sigma^2_{xy}]}}(\overline{z}_x-\overline{z}_y)
\end{aligned}$$

that we can, once more, verify using R:

```{r, out.width="65%", out.height="65%"}

D(expression(log(1+sx*exp(-a*((zx-zy)^2 + var_xy)))), "zx")
D(expression(log(1+sy*exp(-a*((zx-zy)^2 + var_xy)))), "zy")

```

where in the equation that we derived for $\frac{\partial ln\overline{W_x}}{\partial \overline{z}_x}$ we distributed the "-" in front of the expression for the equivalence $-(\overline{z}_x-\overline{z}_y)=(\overline{z}_y-\overline{z}_x)$.

For this section, your task will be to adapt the function that simulate coevolution to incorporate the selection gradients for mutualisms. Then, simulate the coevolutionary dynamics and try to answer the following question:

1.  When mutualistic species coevolve, what is the only possible outcome?

2.  What would be a possible biological mechanism that could change this outcome? As we did in the previous exercise section, think about a mechanism that we could include as an additional assumption in the fitness of individuals of the mutualistic species.

## Incorporating other sources of selective pressure in the environment

For this section we will incorporate other sources of selective pressures in our model of coevolution of two mutualistic species. To do so, we will use a different approach than starting with the fitness function and deriving the selection gradient. Rather, we will directly incorporate another source of selective pressure in the selection gradient.

First, we will simplify the selection gradient that we derived when we have purely mutualistic interactions. In the selection gradients, the terms $\frac{2\alpha s_{x}e^{-\alpha[(\overline{z}_x-\overline{z}_y)^2+\sigma^2_{xy}]}}{1+s_{x}e^{-\alpha[(\overline{z}_x-\overline{z}_y)^2+\sigma^2_{xy}]}}$ and $s_{y}e^{-\alpha[(\overline{z}_x-\overline{z}_y)^2+\sigma^2_{xy}]}}{1+s_{y}e^{-\alpha[(\overline{z}_x-\overline{z}_y)^2+\sigma^2_{xy}]}}$ control the strength of mutualistic selection. For simplicity, we will assume that this term is a constant for both species, $m_{x}$ and $m_{y}$, that controls the contribution of mutualisms as a source of selection for species $x$ and $y$. Next, we will assume that the remaining sources contribute with $(1-m_{x})$ and $(1-m_{y})$ as selective pressures. For these other sources, we will assume that they favor an optimal trait value, $\theta_{x}$ and $\theta_{y}$, that can be different for each species. Under these assumptions the modified selection gradients for species $x$ and $y$ are as follows:

$$\begin{aligned}
\frac{\partial ln\overline{W_x}}{\partial \overline{z}_x} &= m_{x}(\overline{z}_y-\overline{z}_x) + (1-m_{x})(\theta_{x}-\overline{z}_x) \\
\frac{\partial ln\overline{W_y}}{\partial \overline{z}_y} &= m_{y}(\overline{z}_x-\overline{z}_y) + (1-m_{y})(\theta_{y}-\overline{z}_y)
\end{aligned}$$

The parameters $\theta_{x}$ and $\theta_{y}$ can be interpreted biologically as an "environmental optima", for instance, the mean trait values that the conditions of precipitation and temperature in the environment favor for species $x$ and $y$.

Here, your task will be to adapt the function that simulate coevolution to incorporate the modified selection gradients for mutualisms. To do so, we will need to change the parameters that the function that simulate coevolution takes as input, to incorporate $m_{x}$, $m_{y}$, $\theta_{x}$ and $\theta_{y}$. Then, simulate the coevolutionary dynamics and try to answer the following question:

1.  How a second source of selective pressure in the environment changes the coevolutionary dynamics for mutualisms?

2.  How changing the contribution of mutualisms as selective pressure ($m_{x}$ and $m_{y}$) and the environmental optima of species ($\theta_{x}$ and $\theta_{y}$) modify this outcome?

<!--chapter:end:06-ex5.Rmd-->

# Exercise: Coevolution in mutualistic networks

## Simulating coevolution in mutualistic networks

In the lecture, we built a coevolutionary model that describes how the mean value of a continuous trait $\overline{z}_{i}$, for a species $i$, evolves in response to the selective pressures of mutualistic interactions and other sources in the environment that favor an optimal trait value, $\theta_{i}$. This model is a simplified version of the one present in [Guimarães et al. (2017)](https://www.nature.com/articles/nature24273).

The starting point of our model was the classic equation from quantitative genetics by Russel Lande (1976). Using this equation as a starting point, we incorporated the selective pressures of mutualistic interactions and other sources in the environment directly assuming how the selection gradient, $\frac{\partial ln\overline{W_i}}{\partial \overline{z}_i}$, depends on these two sources. We first assumed that for each species $i$, mutualistic interactions contribute with a fraction $m_{i}$ and the environment contributes with the remaining $(1-m_{i})$. Next, we assumed that the selective pressures from mutualistic partners, $m_{i}$, are distributed among all the $j$ partners of species $i$ such that each partner contributes with a fraction $q_{ij}$ to $m_{i}$ and favor trait complementarity, $(\overline{z}_j-\overline{z}_i)$. For simplicity, we set $q_{ij}=\frac{a_{ij}}{\sum_{i=1, i\neq j}^{N}a_{ij}}$, where $a_{ij}=1$ if species $i$ interacts with species $j$ and $a_{ij}=0$ otherwise. Finally, we assumed that the remaining $(1-m_{i})$ sources of selection in the environment favor complementarity with an optimal trait value, $(\theta_{i}-\overline{z}_i)$. Under these assumptions, we arrived at the following equation:

$$
\overline{z}_i^{(t+1)}=\overline{z}_i^{(t)}+h_{i}^2\sigma^2_{i}\left[m_{i}\sum_{i=1, i\neq j}^{N}q_{ij}(\overline{z}_j^{(t)}-\overline{z}_i^{(t)})+(1-m_{i})(\theta_{i}-\overline{z}_i^{(t)}) \right]
$$ where $h^2_{i}$ is the narrow-sense heritability of trait $\overline{z}_i$ and $\sigma^2_{i}$ is the phenotypic variance of trait $\overline{z}_i$, which is assumed to be normally distributed.

To simulate the coevolutionary dynamics using this equation, we will use a slightly different approach than what we have been using so far. Our first step will be to set up a matrix of interactions among species. This matrix will determine the network of interactions among species, and will also determine the number of species, $N$, that will be part of our simulation. For this section we will use the matrices of interactions underlying the networks that we can obtain from the [*Web-of-Life*](www.web-of-life.es) database. To maker it easier I have downloaded all of the mutualistic networks in this database and stored them in a GitHub repository. Using this GitHub repository we can directly import a network to R, as follows:

```{R}

URL1="https://github.com/lgcosmo/evo_coevo/raw/main/networks/M_PA_002.csv" #Setting the URL to one plant-ant network

URL2="https://github.com/lgcosmo/evo_coevo/raw/main/networks/M_PL_011.csv" #Setting the URL to one plant-pollinator network

#Importing the matrices of interactions from the URLs

net1=as.matrix(read.csv(URL1)) 
net2=as.matrix(read.csv(URL2))

```

In the *Web-of-Life database*, all matrices of interactions are in the format of what is called an incidence matrix or a biadjacency matrix. This is a matrix used to represent interactions when we have two distinct sets of species that interact only with species of a different set. For instance, in pollination networks, plants constitute one of the sets, and these plant species interact only with species from the second set, the pollinator species. This type of network of interactions is called a bipartite network. The incidence/biadjacency matrix of this type of network is a matrix whose rows depict species from one of the sets (usually plants in ecology), and columns depict species from the other set (usually animals). Thus the incidence/biadjacency matrix has $N_{plants}$ rows and $N_{animals}$ columns. However, to simulate the coevolutionary model it is easier to work with a matrix containing all species in both rows and columns, such that it has $N$ rows and $N$ columns ($N$ is the total number of species). For this reason, we need to transform the incidence/biadjacency matrix into an adjacency matrix, which can be done as follows:

```{R}

#Getting number of species and total number of species

n_p = nrow(net1) #Number of plant species
n_a = ncol(net1) #Number of animal species
n_sp = n_p+n_a #Total number of species

# Creating adjacency matrix
A1 = rbind(cbind(matrix(0, n_p, n_p), net1), cbind(t(net1), matrix(0, n_a, n_a)))

#Changing labels

rownames(A1) = c(paste0("P", 1:n_p), paste0("A", 1:n_a))
colnames(A1) = c(paste0("P", 1:n_p), paste0("A", 1:n_a))

```

To make our life easier, we can build a function that takes as input an incidence/biadjacency matrix and returns an adjacency matrix:

```{R}

adjacency_matrix<-function(incidence_matrix, binary=TRUE){
  
  n_p <- nrow(incidence_matrix)
  n_a <- ncol(incidence_matrix)
  n_sp <- n_p + n_a
  
  A <- rbind(cbind(matrix(0, n_p, n_p), incidence_matrix),
             cbind(t(incidence_matrix), matrix(0, n_a, n_a)))
  
  rownames(A) = c(paste0("P", 1:n_p), paste0("A", 1:n_a))
  colnames(A) = c(paste0("P", 1:n_p), paste0("A", 1:n_a))
  
  if(binary==TRUE){A[A>0]<-1}
  
  return(A)
  
}

# Using the function for the two networks

A1=adjacency_matrix(incidence_matrix=net1, binary=TRUE)
A2=adjacency_matrix(incidence_matrix=net2, binary=TRUE)

```

We can also quickly visualize how these two networks looks like using the *igraph* package:

```{r, out.width="65%", out.height="65%"}
library(igraph)

#Constructing an igraph object from the adjacency matrix
G1=graph_from_adjacency_matrix(A1, mode=c("undirected"))
G2=graph_from_adjacency_matrix(A2, mode=c("undirected"))

plot(G1, vertex.label=NA)
plot(G2, vertex.label=NA)

```

With our matrix of interactions in hand, our next step will be to define a data structure that will store the mean trait values of each species over time. In this case, since we will be dealing with multiple species, it is better to work with a matrix instead of a vector. This matrix will store in each column the values of $\overline{z}_i$ for each species $i$, and each row will store the values for a given generation $t$, as follows:

```{r, out.width="65%", out.height="65%"}

tmax=100 #Setting the maximum number of time steps in the simulation

n_sp=nrow(A1) #Setting a number of species. It is equal to the number of rows in the matrix of interactions.

dz=matrix(data=NA, nrow=tmax, ncol=n_sp)
colnames(dz)=paste0("SP", 1:n_sp)

print(dz[1:5,]) #Visualizing the first 5 rows

```

The dimensions of this matrix will depend on the number of species and maximum number of time steps of our simulation. For simplicity, from now on we will work with the matrix "A1", but feel free to use a different network.

Next, as we did before, we need to define some of the parameters of the model, such as $h^2_{i}$, $\sigma^2_{i}$, $m_{i}$, $\theta_{i}$ and initial mean trait values for each species, $\overline{z}_{0,i}$. When we have $N$ species, we also need to choose $N$ values for each of these parameters. The number of values can get out of control quickly and to avoid this we will use the same values of $h^2_{i}$, $\sigma^2_{i}$ and $m_{i}$ for all species. For $\theta_{i}$ and $\overline{z}_{0,i}$, we will sample these parameters from a uniform distribution from an interval between 0 and 10. The code to do so is reproduced below:

```{r, out.width="65%", out.height="65%"}

var_z=rep(0.5, n_sp) #Setting the trait variance to a certain value for all species
h=rep(0.5, n_sp) #Setting the heritability to a certain value for all species
m=rep(0.5, n_sp) #Setting the contribution of mutualisms as a source of selection to a certain value for all species

z0=runif(n_sp, min=0, max=10) #Sampling initial mean trait values of each species from a uniform distribution
theta=runif(n_sp, min=0, max=10) #Sampling the environmental optima of each species from a uniform distribution

```

These values will be passed as arguments to a function that we will use to simulate the coevolutionary model. In this function, we will first set initial mean trait values for all species and then perform the following set of operations inside a *for loop*:

1.  Set mean trait values of all species at generation $t$.

2.  Compute the matrix of evolutionary effects, $Q$. Each entry of this matrix will be equal to $q_{ij}=\frac{a_{ij}}{\sum_{i=1, i\neq j}^{N}a_{ij}}$. This is equivalent as getting each entry of the adjacency matrix, $A$, and dividing them by the sum of their corresponding row. Then, we multiply each row of this matrix by $m_{i}$. Remember that each row in the matrix $Q$ corresponds to a species $i$, and each column represents the contribution of each species $j$ to the evolution of $i$.

3.  Compute all pairwise differences in the mean trait values of species, $(\overline{z}_j-\overline{z}_i)$. The result will be another matrix with entries corresponding to the differences in the trait of species $j$ and species $i$.

4.  Multiply the matrix of pairwise evolutionary effects $Q$, with the matrix of pairwise differences in traits.

5.  Compute the selection gradient as described in the equation of the coevolutionary model.

6.  Compute mean trait values at the next generation using Lande\`s equation.

These steps are highlighted in the code below:

```{r, out.width="65%", out.height="65%"}

coevo_network<-function(incidence_matrix, m, z0, theta, h, var_z, tmax){
  
  # Setting up adjacency matrix and the data structure to store mean trait values over time for the simulation
  A=adjacency_matrix(incidence_matrix=incidence_matrix, binary=TRUE)
  n_sp=nrow(A)
  dz=matrix(NA, nrow = tmax, ncol = n_sp)
  
  dz[1,]<-z0 # Setting initial trait values
  
  for(t in 1:(tmax-1)){
    
    z = dz[t, ] # Step (1)
    
    Q = A / rowSums(A) # Step (2)
    Q = Q * m # Step (2)
    
    z_dif = t(A*z) - A*z # Step (3)
    
    Q_dif = Q * z_dif # Step (4)
    
    mut_sel = rowSums(Q_dif) # Step (5)
    env_sel = (1 - m)*(theta - z) # Step (5)
    dlnw = mut_sel+env_sel # Step (5)
    
    dz[t+1, ] = z + h*var_z*dlnw # Step (6)
    
  }
  
  # Setting up a data farme with results
  dz_df<-as.data.frame(dz)
  dz_df$time<-1:tmax
  names(dz_df)[1:n_sp]<-paste0("SP", 1:n_sp)
  dz_df<-melt(dz_df, id.vars="time")
  
  return(dz_df)
  
}

```

With the function in hand we can now run it and plot the results:

```{r, out.width="65%", out.height="65%"}

library(reshape2)
library(ggplot2)
library(ggpubr)

var_z=rep(0.5, n_sp) 
h=rep(0.5, n_sp) 
m=rep(0.5, n_sp) 
z0=runif(n_sp, min=0, max=10)
theta=runif(n_sp, min=0, max=10) 

r=coevo_network(incidence_matrix=net1, m=m, z0=z0, theta=theta, h=h, var_z=var_z, tmax=200)

ggplot()+
  geom_line(data=r, aes(x=time, y=value, color=variable))+
  xlab("Generation")+ylab("Mean trait values")+
  theme_pubr()+theme(legend.position="none")

```

In the plot above, lines of different colors represent the coevolutionary trajectory of the mean trait values of different species. With this function, try to explore how different values of $m_{i}$ change the coevolutionary dynamics. Think about what differences can you observe from the scenario where only two mutualistic species coevolve.

## Quantifying indirect evolutionary effects

In the lecture we studied that our model for coevolution in mutualistic networks has a stable equilibrium point. This equilibrium point is depicted by the following matrix-vector equation:

$$
\vec{\overline{z}^*}=(I-Q)^{-1}\Psi\vec{\theta}
$$

In the equation above, the matrix $\left(I-Q\right)^{-1}$ is a matrix containing the direct and indirect evolutionary effects that each species exert on each other. This interpretation can be recovered by the matrix power series:

$$
\left(I-Q\right)^{-1}=\sum_{k=0}^{\infty}Q^{k}
$$ The entries of each matrix $Q^{k}$, in turn, contain the effects that species $j$ exert on species $i$ through a pathway of length $k$. Thus, each matrix in the series depicted in the equation above corresponds to a matrix containing the effects from pathways of length $k$ among all species. Therefore, the equilibrium solution of the coevolutionary model represents a scenario in which direct and indirect evolutionary effects connect the selective pressures coming from the environment ($\theta_{i}$) across all species in the network.

Since the matrix of direct interactions is known, we can use the matrix $T=(I-Q)^{-1}\Psi$ to quantify what is the contribution of indirect evolutionary effects to the evolution of species in the network. To do so, we need to perform the following steps:

1.  Obtain the matrix of direct evolutionary effects, $Q$ and the matrix $\Psi$, which is a diagonal matrix with diagonal $\Psi_{i}=(1-m_{i})$.

2.  Compute the matrix $T=(I-Q)^{-1}\Psi$ and set its diagonal to 0.

3.  Create a new matrix, $T_{indirect}$ and set all its entries of the matrix $T$ containing direct interactions to 0.

4.  Compute the contribution of indirect effects as the ratio of the sum of all of the entries of the matrix $T_{indirect}$ to the sum of the entries of the complete matrix $T$.

The code to do so is reproduced inside a function below:

```{r, out.width="65%", out.height="65%"}

indirect_effects=function(incidence_matrix, m){
  
  # Getting adjacency matrix
  A=adjacency_matrix(incidence_matrix=incidence_matrix, binary=TRUE)
  
  n_sp=nrow(A)
  
  Q = A / apply(A,1,sum) # Step (1)
  Q = Q * m # Step (1)
  
  Psi = diag((1-m), n_sp) # Step (1)
  I = diag(1, n_sp) # Creating identity matrix
  
  Tmat=(solve(I-Q)) %*% Psi # Step (2)
  diag(Tmat)=0
  
  Tmat_indirect=Tmat #Step (3)
  Tmat_indirect=Tmat_indirect*(1-A) #Step (3)
  
  ind_contrib=sum(Tmat_indirect)/sum(Tmat) #Step (4)
  
  return(ind_contrib)
  
}

# Using the function

ind_net1 = indirect_effects(incidence_matrix=net1, m=0.5)
ind_net2 = indirect_effects(incidence_matrix=net2, m=0.5)

print(ind_net1)
print(ind_net2)

```

Looking at these two networks, try to explain why there is a difference in the contribution of indirect effects. Furthermore, using the function, try to explore how changing the value of $m_{i}$ modifies the contribution of indirect evolutionary effects.

<!--chapter:end:07-ex6.Rmd-->

