p1+p2+p3+p4 + plot_annotation(tag_levels=c("a"))
library(patchwork)
# Creating a data frame with variables z, the squared deviations of z to the mean, and the fitness of individuals in the population when using fitness functions (2) and (3)
z_df = data.frame(z=z, z2=(z-mean(z))^2, w2=w2, w3=w3)
# Creating plots with the regression between z and w2, as well as (z-mean(z))^2 for w2
p1 = ggplot(data=z_df, aes(x=z, y=w2))+
geom_point()+
xlab("Trait values")+ylab("Fitness (function #2)")+
geom_smooth(method="lm", se=F)+
theme_pubr()
p2 = ggplot(data=z_df, aes(x=z2, y=w2))+
geom_point()+
xlab("Squared deviation of trait values to the mean")+ylab("Fitness (function #2)")+
geom_smooth(method="lm", se=F)+
theme_pubr()
# Creating plots with the regression between z and w2, as well as (z-mean(z))^2 for w3
p3 = ggplot(data=z_df, aes(x=z, y=w3))+
geom_point()+
xlab("Trait values")+ylab("Fitness (function #3)")+
geom_smooth(method="lm", se=F)+
theme_pubr()
p4 = ggplot(data=z_df, aes(x=z2, y=w3))+
geom_point()+
xlab("Squared deviation of trait values to the mean")+ylab("Fitness (function #3)")+
geom_smooth(method="lm", se=F)+
theme_pubr()
# Combining all plots using the patchwork package
p1+p2+p3+p4 + plot_annotation(tag_levels=c("a"))
D(x^2, x)
D(x^2, "x")
D(expression(x^2), "x")
g<-D(expression(x^2), "x")
g
str(g)
g(2)
g<-D(expression(exp(-a*(theta-z)^2)), "z")
g
g<-D(expression(log(exp(-a*(theta-z)^2))), "z")
g
g<-D(expression(-a*(theta-z)^2), "z")
g
a*(2*(theta - z))
a<-0.2
g<-D(expression(-a*(theta-z)^2), "z")
g
library(reshape2)
library(ggplot2)
library(ggpubr)
x_dp = c()
y_dp = c()
x_p0 = 0.3
y_p0 = 0.3
x_dp[1] = x_p0
y_dp[1] = y_p0
sx = 0.2
sy = 0.1
AA = 1
AB = 0
BA = 0
BB = 1
Q = matrix(data=c(AA,BA,AB,BB), nrow=2, ncol=2)
rownames(Q)=c("Ax", "Bx")
colnames(Q)=c("Ay", "By")
View(Q)
#Creating a 2x2 matrix with entries corresponding to the gene-for-gene one studied in the lecture
A=matrix(data=c(1,1,0,1), nrow=2, ncol=2)
A
#Creating a 2x2 matrix with entries corresponding to the gene-for-gene one studied in the lecture
A=matrix(data=c(1,1,0,1), nrow=2, ncol=2)
rownames(A)=c("Ax", "Bx") #Changing row names to facilitate visualization
colnames(A)=c("Ay", "By") #Changing column names to facilitate visualization
A
# Step (1)
#Defining a function that takes as input the following parameters:
#A=Matrix of effects between alleles
#sx=Overall strength of ecological interactions on fitness of the victim species
#sy=Overall strength of ecological interactions on fitness of the exploiter species
#p0_x=Initial frequency of allele A of the victim species
#p0_y=Initial frequency of allele A of the exploiter
coevo<-function(A, sx, sy, tmax, p0_y, p0_x){ #Step (1)
x_dp = c() #Creating vector to store values of the frequency of allele A for the victim species
y_dp = c() #Creating vector to store values of the frequency of allele A for the exploiter species
x_dp[1] = p0_x #Setting initial frequency of allele A for the victim species
y_dp[1] = p0_y #Setting initial frequency of allele A for the exploiter species
#For loop to iterate over the equation
for(t in 1:(tmax-1)){
# Step (2)
xp = x_dp[t] #Setting current frequency of allele A for the victim species
yp = y_dp[t] #Setting current frequency of allele A for the exploiter species
# Step (3)
x_wA = 1 - sx*(A[1,1]*yp + A[1,2]*(1-yp)) #Computing the fitness of allele A for the victim species
x_wB = 1 - sx*(A[2,1]*yp + A[2,2]*(1-yp)) #Computing the fitness of allele B for the victim species
x_avg_w = xp*x_wA + (1-xp)*x_wB #Computing the average fitness of the population of the victim species
y_wA = 1 + sy*(A[1,1]*xp + A[2,1]*(1-xp)) #Computing the fitness of allele A for the exploiter species
y_wB = 1 + sy*(A[1,2]*xp + A[2,2]*(1-xp)) #Computing the fitness of allele B for the exploiter species
y_avg_w = yp*y_wA + (1-yp)*y_wB #Computing the average fitness of the population of the exploiter species
# Step (4)
x_dp[t+1]=xp + ((xp*(1-xp)*(x_wA-x_wB))/x_avg_w) #Using Wright's equaiton to compute frequency of A in the next generation for the victim species
y_dp[t+1]=yp + ((yp*(1-yp)*(y_wA-y_wB))/y_avg_w) #Using Wright's equaiton to compute frequency of A in the next generation for the exploiter species
}
r=data.frame(x_dp, y_dp, t=1:tmax) # Step (5), creating a data frame with frequencies over time
return(r)
}
#Creating a 2x2 matrix with entries corresponding to the gene-for-gene one studied in the lecture
A=matrix(data=c(1,1,0,1), nrow=2, ncol=2)
rownames(A)=c("Ax", "Bx") #Changing row names to facilitate visualization
colnames(A)=c("Ay", "By") #Changing column names to facilitate visualization
A
#Running the coevolutionary model
r=coevo(A=A, sx=0.1, sy=0.1, tmax=100, p0_y=0.2, p0_x=0.2)
#
View(r)
View(r)
ggplot()+
geom_line(data=r, aes(x=t, y=x_dp), color="royalblue3")+ # Frequency of allele A for victims, in blue
geom_line(data=r, aes(x=t, y=y_dp), color="firebrick3")+ #Frequency of allele A for exploiters, in red
theme_pubr()
library(ggplo2)
library(ggplot2)
library(ggpubr)
ggplot()+
geom_line(data=r, aes(x=t, y=x_dp), color="royalblue3")+ # Frequency of allele A for victims, in blue
geom_line(data=r, aes(x=t, y=y_dp), color="firebrick3")+ #Frequency of allele A for exploiters, in red
theme_pubr()
#Running the coevolutionary model
r=coevo(A=A, sx=0.1, sy=0.1, tmax=100, p0_y=0.2, p0_x=0.2)
#Plotting the results
library(ggplot2)
library(ggpubr)
ggplot()+
geom_line(data=r, aes(x=t, y=x_dp), color="royalblue3")+ # Frequency of allele A for victims, in blue
geom_line(data=r, aes(x=t, y=y_dp), color="firebrick3")+ #Frequency of allele A for exploiters, in red
xlab("Generations")+ylab("Frequency of allele A")+
theme_pubr()
#Running the coevolutionary model
r=coevo(A=A, sx=0.2, sy=0.1, tmax=100, p0_y=0.2, p0_x=0.2)
#Plotting the results
library(ggplot2)
library(ggpubr)
ggplot()+
geom_line(data=r, aes(x=t, y=x_dp), color="royalblue3")+ # Frequency of allele A for victims, in blue
geom_line(data=r, aes(x=t, y=y_dp), color="firebrick3")+ #Frequency of allele A for exploiters, in red
xlab("Generations")+ylab("Frequency of allele A")+
theme_pubr()
#Running the coevolutionary model
r=coevo(A=A, sx=0.1, sy=0.2, tmax=100, p0_y=0.2, p0_x=0.2)
#Plotting the results
library(ggplot2)
library(ggpubr)
ggplot()+
geom_line(data=r, aes(x=t, y=x_dp), color="royalblue3")+ # Frequency of allele A for victims, in blue
geom_line(data=r, aes(x=t, y=y_dp), color="firebrick3")+ #Frequency of allele A for exploiters, in red
xlab("Generations")+ylab("Frequency of allele A")+
theme_pubr()
dw=D(expression(log(1+beta*z)), "z")
print(dw)
dw2=D(expression(log(exp(-a*(theta-z)^2+v))), "z") #v here corresponds to the variance in the equation
print(dw)
dw2=D(expression(log(exp(-a*(theta-z)^2+v))), "z") #v here corresponds to the variance in the equation
print(dw2)
dw2=D(expression(-a*((theta-z)^2+v)), "z") #v here corresponds to the variance in the equation
print(dw2)
dz = c() #Defining vector to store trait values over time
z0 = 1 #Defining initial trait value in the population
dz[1] = z0 #Defining initial trait value in the population
tmax=100 # Number of generations
varG=0.1 # Additive genetic variance
beta=0.5 #Parameter beta
for(t in 1:(tmax-1)){ #Setting up the for loop
z = dz[t] # Setting current trait values
dlnw = (beta/(1+beta*z))  #Computing the selection gradient of fitness function 1
dz[t+1]= z + varG*dlnw #Updating trait values using Lande's equation
}
dz
library(ggplot2)
library(ggpubr)
evo_simulation<-function(tmax, z0, varG, beta){
dz = c() #Defining vector to store trait values over time
dz[1] = z0 #Defining initial trait value in the population
for(t in 1:(tmax-1)){ #Setting up the for loop
z = dz[t] # Setting current trait values
dlnw = (beta/(1+beta*z))  #Computing the selection gradient of fitness function 1
dz[t+1]= z + varG*dlnw #Updating trait values using Lande's equation
}
r = data.frame(dz=dz, t=1:tmax) # Building the data frame with trait values over time
return(r)
}
# Running the function to test it:
r = evo_simulation(tmax=100, z0=1, varG=0.1, beta=0.5)
# Plotting the result
ggplot()+
geom_line(data=r, aes(x=t, y=dz))+
xlab("Generation")+ylab("Frequency of allele A")+
theme_pubr()
library(ggplot2)
library(ggpubr)
evo_simulation<-function(tmax, z0, varG, beta){
dz = c() #Defining vector to store trait values over time
dz[1] = z0 #Defining initial trait value in the population
for(t in 1:(tmax-1)){ #Setting up the for loop
z = dz[t] # Setting current trait values
dlnw = (beta/(1+beta*z))  #Computing the selection gradient of fitness function 1
dz[t+1]= z + varG*dlnw #Updating trait values using Lande's equation
}
r = data.frame(dz=dz, t=1:tmax) # Building the data frame with trait values over time
return(r)
}
# Running the function to test it:
r = evo_simulation(tmax=100, z0=1, varG=0.1, beta=0.5)
# Plotting the result
ggplot()+
geom_line(data=r, aes(x=t, y=dz))+
xlab("Generation")+ylab("Mean trait value in the population")+
theme_pubr()
beta=0.5 #Defining parameter beta
z = seq(0, 10, 0.001) # Step 1
w_avg = 1+beta*z #Step 2
land = data.frame(z, w_avg) #Building a data frame with values of p and the corresponding average fitness
# Plotting the landscape.
ggplot()+
geom_line(data=land, aes(x=z, y=w_avg))+
xlab("Average trait value in the population")+ylab("Average fitness of the population")+
theme_pubr()
beta=2 #Defining parameter beta
z = seq(0, 10, 0.001) # Step 1
w_avg = 1+beta*z #Step 2
land = data.frame(z, w_avg) #Building a data frame with values of p and the corresponding average fitness
# Plotting the landscape.
ggplot()+
geom_line(data=land, aes(x=z, y=w_avg))+
xlab("Average trait value in the population")+ylab("Average fitness of the population")+
theme_pubr()
beta=0.5 #Defining parameter beta
z = seq(0, 10, 0.001) # Step 1
w_avg = 1+beta*z #Step 2
land = data.frame(z, w_avg) #Building a data frame with values of p and the corresponding average fitness
# Plotting the landscape.
ggplot()+
geom_line(data=land, aes(x=z, y=w_avg))+
xlab("Average trait value in the population")+ylab("Average fitness of the population")+
theme_pubr()
file.create('.nojekyll')
dp = c()
dp
p0 = 0.1
p0 = 0.1
dp[1] = p0
dp[1] = p0
wA = 2
wB = 1
tmax = 100
for(t in 1:(tmax-1)){
p = dp[t]
w_avg = p*wA + (1-p)*wB
dp[t+1] = p + (p*(1-p)*(wA-wB)/w_avg)
}
dp
library(ggplot2)
library(ggpubr)
r = data.frame(dp=dp, t=1:tmax)
View(r)
ggplot()+
geom_line(data=r, aes(x=t, y=dp))+
xlab("Generation")+ylab("Frequency of allele A")+
theme_pubr()
evo_simulation<-function(tmax, p0, wA, wB){ #Defining the function and the input arguments
dp = c() #Creating the vector to store the outcome
dp[1]<-p0 #Setting the initial frequency of p
for(t in 1:(tmax-1)){ #Setting up the for loop
p = dp[t] # Step 1
w_avg = p*wA + (1-p)*wB #Step 2
dp[t+1]= p + (p*(1-p)*(wA-wB)/w_avg) #Step 3
}
r = data.frame(dp=dp, t=1:tmax) # Building the data frame
return(r)
}
df=evo_simulation(tmax=100, p0=0.1, wA=2, wB=3)
View(df)
ggplot()+
geom_line(data=df, aes(x=t, y=dp))+
xlab("Generation")+ylab("Frequency of allele A")+
theme_pubr()
df=evo_simulation(tmax=100, p0=0.8, wA=2, wB=3)
ggplot()+
geom_line(data=df, aes(x=t, y=dp))+
xlab("Generation")+ylab("Frequency of allele A")+
theme_pubr()
df=evo_simulation(tmax=100, p0=0.8, wA=4, wB=3)
ggplot()+
geom_line(data=df, aes(x=t, y=dp))+
xlab("Generation")+ylab("Frequency of allele A")+
theme_pubr()
df=evo_simulation(tmax=100, p0=0.8, wA=4, wB=4)
ggplot()+
geom_line(data=df, aes(x=t, y=dp))+
xlab("Generation")+ylab("Frequency of allele A")+
theme_pubr()
evo_simulation<-function(tmax, p0, alpha, beta){ #Defining the function and the input arguments
dp = c() #Creating the vector to store the outcome
dp[1]<-p0 #Setting the initial frequency of p
for(t in 1:(tmax-1)){ #Setting up the for loop
p = dp[t] # Setting current frequency
wA = 1-(alpha*p) #Computing the fitness of A at the current generation
wB = 1-(beta*(1-p)) #Computing the fitness of B at the current generation
w_avg = p*wA + (1-p)*wB #Computing the average fitness of the population
dp[t+1]= p + (p*(1-p)*(wA-wB)/w_avg) #Updating frequencies
}
r = data.frame(dp=dp, t=1:tmax) # Building the data frame
return(r)
}
r = evo_simulation(tmax=50, p0=0.2, alpha=0.1, beta=0.2)
View(r)
ggplot()+
geom_line(data=r, aes(x=t, y=dp))+
xlab("Generation")+ylab("Frequency of allele A")+
scale_y_continuous(limits=c(0,1))+ #Setting the limits on the y-axis to be the same as in the previous model
theme_pubr()
r = evo_simulation(tmax=100, p0=0.2, alpha=0.1, beta=0.2)
ggplot()+
geom_line(data=r, aes(x=t, y=dp))+
xlab("Generation")+ylab("Frequency of allele A")+
scale_y_continuous(limits=c(0,1))+ #Setting the limits on the y-axis to be the same as in the previous model
theme_pubr()
r = evo_simulation(tmax=100, p0=0.2, alpha=0.1, beta=0.1)
ggplot()+
geom_line(data=r, aes(x=t, y=dp))+
xlab("Generation")+ylab("Frequency of allele A")+
scale_y_continuous(limits=c(0,1))+ #Setting the limits on the y-axis to be the same as in the previous model
theme_pubr()
wA = 2 # Step 1
wB = 1 # Step 1
p = seq(0, 1, 0.001)
p
w_avg = p*wA + (1-p)*wB #Step 3
w_avg
land = data.frame(p, w_avg) #Building a data frame with values of p and the corresponding average fitness
ggplot()+
geom_line(data=land, aes(x=p, y=w_avg))+
xlab("Frequency of allele A")+ylab("Average fitness of the population")+
theme_pubr()
wA = 0.5 # Step 1
wB = 1 # Step 1
p = seq(0, 1, 0.001)
w_avg = p*wA + (1-p)*wB #Step 3
land = data.frame(p, w_avg) #Building a data frame with values of p and the corresponding average fitness
ggplot()+
geom_line(data=land, aes(x=p, y=w_avg))+
xlab("Frequency of allele A")+ylab("Average fitness of the population")+
theme_pubr()
evo_landscape<-function(tmax, p0, wA, wB){ #Defining the function and the input arguments
p_theo = seq(0, 1, 0.001) # Defining the theoretical values of p to build the fitness landscape
w_avg_theo = p_theo*wA + (1-p_theo)*wB #Computing the average fitness
land = data.frame(p_theo, w_avg_theo) #Building a data frame with values of p and the corresponding average fitness
dp = c() #Creating the vector to store the outcome
dw = c() #Creating a vector to keep track of the average fitness along the evolutionary dynamics
dp[1]<-p0 #Setting the initial frequency of p
for(t in 1:(tmax-1)){ #Setting up the for loop
p = dp[t] # Setting current frequencies
w_avg = p*wA + (1-p)*wB # Computing average fitness
dw[t] = w_avg
dp[t+1]= p + (p*(1-p)*(wA-wB)/w_avg) #Updating frequency values
}
dw[tmax] =  dp[tmax]*wA + (1-dp[tmax])*wB #Computing average fitness for the final time step
r = data.frame(dp=dp, dw, t=1:tmax) # Building the data frame
return(list(land, r)) # Returning a list with the data frame of the dynamics and the landscape, respectively
}
r_list = evo_landscape(tmax=20, p0=0.2, wA=1.5, wB=1)
View(r_list)
ggplot()+
geom_line(data=r_list[[1]], aes(x=p_theo, y=w_avg_theo))+
geom_point(data=r_list[[2]], aes(x=dp, y=dw, fill=t), color="black", shape=21, size=3)+
scale_fill_gradientn(colors=c("white", "black"))+
labs(fill="Generation")+
xlab("Frequency of allele A")+ylab("Average fitness of the population")+
theme_pubr()
r_list = evo_landscape(tmax=20, p0=0.2, wA=1, wB=1.5)
ggplot()+
geom_line(data=r_list[[1]], aes(x=p_theo, y=w_avg_theo))+
geom_point(data=r_list[[2]], aes(x=dp, y=dw, fill=t), color="black", shape=21, size=3)+
scale_fill_gradientn(colors=c("white", "black"))+
labs(fill="Generation")+
xlab("Frequency of allele A")+ylab("Average fitness of the population")+
theme_pubr()
evo_landscape<-function(tmax, p0, alpha, beta){ #Defining the function and the input arguments
p_theo = seq(0, 1, 0.001) # Defining the theoretical values of p to build the fitness landscape
wA_theo = 1 - (alpha*p_theo) # Defining the fitness function of A
wB_theo = 1 - (beta*(1-p_theo)) # Defining the fitness function of A
w_avg_theo = p_theo*wA_theo + (1-p_theo)*wB_theo #Computing the average fitness
land = data.frame(p_theo, w_avg_theo) #Building a data frame with values of p and the corresponding average fitness
dp = c() #Creating the vector to store the outcome
dw = c() #Creating a vector to keep track of the average fitness along the evolutionary dynamics
dp[1]<-p0 #Setting the initial frequency of p
for(t in 1:(tmax-1)){ #Setting up the for loop
p = dp[t] # Setting current frequencies
wA = 1-(alpha*p) #Computing the fitness of A at the current generation
wB = 1-(beta*(1-p)) #Computing the fitness of B at the current generation
w_avg = p*wA + (1-p)*wB # Computing average fitness
dw[t] = w_avg
dp[t+1]= p + (p*(1-p)*(wA-wB)/w_avg) #Updating frequency values
}
dw[tmax] =  dp[tmax]*wA + (1-dp[tmax])*wB #Computing average fitness for the final time step
r = data.frame(dp=dp, dw, t=1:tmax) # Building the data frame
return(list(land, r)) # Returning a list with the data frame of the dynamics and the landscape, respectively
}
r_list = evo_landscape(tmax=50, p0=0.2, alpha=0.1, beta=0.2)
ggplot()+
geom_line(data=r_list[[1]], aes(x=p_theo, y=w_avg_theo))+
geom_point(data=r_list[[2]], aes(x=dp, y=dw, fill=t), color="black", shape=21, size=3)+
scale_fill_gradientn(colors=c("white", "black"))+
labs(fill="Generation")+
xlab("Frequency of allele A")+ylab("Average fitness of the population")+
theme_pubr()
library(ggplot2)
library(ggpubr)
n=10000 #Population size
z_u=5 #Mean trait value
z_var=1 #Variance
z = rnorm(n, mean=z_u, sd=sqrt(z_var)) #Sampling from a normal distribution with mean=5 and variance=1 (the standard deviation is equal to the square root of the variance).
# Plotting the distribution
ggplot(data=data.frame(z))+
geom_density(aes(x=z))+
xlab("Trait value")+ylab("Density")+
theme_pubr()
e=rnorm(n, mean=0, sd=0.05) #Sampling random noise
c=1 # Parameter of fitness function (1)
beta=0.5 # Parameter of fitness functions (2)
alpha=0.5; theta=4.0 # Parameters of fitness function (3)
w1=1+c+e #Fitness function (1)
w2=1+beta*z+e #Fitness function (2)
w3=1+exp(-alpha*(theta-z+e)^2) #Fitness function (3)
delta_z=cov(w1,z)/mean(w1) #Change in the mean of z
delta_zvar=cov(w1,(z-mean(z))^2)/mean(w1) #Change in the variance of z
z_new=rnorm(n, mean=z_u+delta_z, sd=sqrt(z_var+delta_zvar))
ggplot(data=data.frame(z=z, z_new=z_new))+
geom_density(aes(x=z), linetype="dashed")+
geom_density(aes(x=z_new))+
xlab("Trait value")+ylab("Counts")+
theme_pubr()
ggplot()+
ggplot(data=data.frame(z, w1), aes(x=z, y=w1))+
theme_pubr()
ggplot()+
geom_point(data=data.frame(z, w1), aes(x=z, y=w1))+
theme_pubr()
ggplot()+
geom_point(data=data.frame(z, w2), aes(x=z, y=w2))+
theme_pubr()
library(patchwork)
z_df = data.frame(z=z, z2=(z-mean(z))^2, w2=w2, w3=w3)
p1 = ggplot(data=z_df, aes(x=z, y=w2))+
geom_point()+
xlab("Trait values")+ylab("Fitness (function #2)")+
geom_smooth(method="lm", se=F)+
theme_pubr()
p2 = ggplot(data=z_df, aes(x=z2, y=w2))+
geom_point()+
xlab("Squared deviation of trait values to the mean")+ylab("Fitness (function #2)")+
geom_smooth(method="lm", se=F)+
theme_pubr()
p3 = ggplot(data=z_df, aes(x=z, y=w3))+
geom_point()+
xlab("Trait values")+ylab("Fitness (function #3)")+
geom_smooth(method="lm", se=F)+
theme_pubr()
p4 = ggplot(data=z_df, aes(x=z2, y=w3))+
geom_point()+
xlab("Squared deviation of trait values to the mean")+ylab("Fitness (function #3)")+
geom_smooth(method="lm", se=F)+
theme_pubr()
p1+p2+p3+p4 + plot_annotation(tag_levels=c("a"))
w=exp(-0.5*(theta1-z)^2)+exp(-0.5*(theta2-z)^2)
theta1=5
theta2=2
z=rnorm(10000, mean=3, sd=1)
w=exp(-0.5*(theta1-z)^2)+exp(-0.5*(theta2-z)^2)
plot(w~z)
ggplot()+
geom_point(data=data.frame(z=z, w=w, zvar=(z-mean(z))^2), aes(x=z, y=w))+
geom_smooth()+
theme_pubr()
library(ggplot2)
library(ggpubr)
ggplot()+
geom_point(data=data.frame(z=z, w=w, zvar=(z-mean(z))^2), aes(x=z, y=w))+
geom_smooth()+
theme_pubr()
ggplot(data=data.frame(z=z, w=w, zvar=(z-mean(z))^2))+
geom_point(aes(x=z, y=w))+
geom_smooth()+
theme_pubr()
ggplot(data=data.frame(z=z, w=w, zvar=(z-mean(z))^2))+
geom_point(aes(x=z, y=w))+
geom_smooth(method="lm")+
theme_pubr()
ggplot(data=data.frame(z=z, w=w, zvar=(z-mean(z))^2))+
geom_point(aes(x=z, y=w))+
geom_smooth(method="lm", aes(x=z, y=w))+
theme_pubr()
ggplot(data=data.frame(z=z, w=w, zvar=(z-mean(z))^2))+
geom_point(aes(x=zvar, y=w))+
geom_smooth(method="lm", aes(x=zvar, y=w))+
theme_pubr()
z=rnorm(10000, mean=3.5, sd=1)
w=exp(-0.5*(theta1-z)^2)+exp(-0.5*(theta2-z)^2)
ggplot(data=data.frame(z=z, w=w, zvar=(z-mean(z))^2))+
geom_point(aes(x=zvar, y=w))+
geom_smooth(method="lm", aes(x=zvar, y=w))+
theme_pubr()
ggplot(data=data.frame(z=z, w=w, zvar=(z-mean(z))^2))+
geom_point(aes(x=z, y=w))+
geom_smooth(method="lm", aes(x=z, y=w))+
theme_pubr()
